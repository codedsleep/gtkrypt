{
  "version": 3,
  "sources": ["../../../tests/harness.ts", "../../../src/services/naming.ts", "../../../tests/unit/naming.test.ts"],
  "sourcesContent": ["/**\n * Minimal GJS test harness with assertion helpers.\n *\n * Each test file imports from this module, runs assertions, and\n * calls `report()` at the end. Non-zero exit on any failure.\n */\n\nlet _passed = 0;\nlet _failed = 0;\nconst _errors: string[] = [];\n\nexport function assert(condition: boolean, message: string): void {\n  if (condition) {\n    _passed++;\n  } else {\n    _failed++;\n    _errors.push(`  FAIL: ${message}`);\n  }\n}\n\nexport function assertEqual<T>(actual: T, expected: T, message: string): void {\n  if (actual === expected) {\n    _passed++;\n  } else {\n    _failed++;\n    _errors.push(`  FAIL: ${message}\\n    expected: ${String(expected)}\\n    actual:   ${String(actual)}`);\n  }\n}\n\nexport function assertDeepEqual(actual: Uint8Array, expected: Uint8Array, message: string): void {\n  if (actual.length !== expected.length) {\n    _failed++;\n    _errors.push(`  FAIL: ${message}\\n    length mismatch: expected ${expected.length}, got ${actual.length}`);\n    return;\n  }\n  for (let i = 0; i < actual.length; i++) {\n    if (actual[i] !== expected[i]) {\n      _failed++;\n      _errors.push(`  FAIL: ${message}\\n    byte ${i} differs: expected ${expected[i]}, got ${actual[i]}`);\n      return;\n    }\n  }\n  _passed++;\n}\n\nexport function assertThrows(fn: () => void, errorName: string, message: string): void {\n  try {\n    fn();\n    _failed++;\n    _errors.push(`  FAIL: ${message}\\n    expected ${errorName} to be thrown, but nothing was thrown`);\n  } catch (e: unknown) {\n    const err = e as { name?: string };\n    if (err.name === errorName) {\n      _passed++;\n    } else {\n      _failed++;\n      _errors.push(`  FAIL: ${message}\\n    expected ${errorName}, got ${err.name ?? String(e)}`);\n    }\n  }\n}\n\nexport function assertBigIntEqual(actual: bigint, expected: bigint, message: string): void {\n  if (actual === expected) {\n    _passed++;\n  } else {\n    _failed++;\n    _errors.push(`  FAIL: ${message}\\n    expected: ${String(expected)}\\n    actual:   ${String(actual)}`);\n  }\n}\n\nexport function report(suiteName: string): void {\n  if (_errors.length > 0) {\n    printerr(`\\n${suiteName}:`);\n    for (const err of _errors) {\n      printerr(err);\n    }\n  }\n  print(`${suiteName}: ${_passed} passed, ${_failed} failed`);\n  if (_failed > 0) {\n    imports.system.exit(1);\n  }\n}\n", "/**\n * Output filename generation and conflict resolution.\n *\n * Provides deterministic, user-friendly output paths for both\n * encryption and decryption operations. When a target path already\n * exists on disk the module appends a numeric suffix -- `(1)`,\n * `(2)`, etc. -- until an unused name is found.\n */\n\nimport Gio from \"gi://Gio\";\nimport GLib from \"gi://GLib\";\n\n/** File extension used for encrypted containers. */\nexport const EXTENSION = \".gtkrypt\";\n\n/** Maximum number of conflict-resolution attempts before giving up. */\nconst MAX_CONFLICT_ATTEMPTS = 1000;\n\n/**\n * Resolve a filename conflict by appending a numeric suffix.\n *\n * Given `/dir/photo.jpg.gtkrypt`, this tries in order:\n *   - `/dir/photo.jpg (1).gtkrypt`\n *   - `/dir/photo.jpg (2).gtkrypt`\n *   - ...\n *\n * The suffix is inserted before the *last* extension so the final\n * file still has the expected extension type.\n *\n * @param basePath - The desired output path that already exists.\n * @returns A path that does not yet exist on disk.\n * @throws If no available name is found within {@link MAX_CONFLICT_ATTEMPTS}.\n */\nfunction resolveConflict(basePath: string): string {\n  const dir = GLib.path_get_dirname(basePath);\n  const fullName = GLib.path_get_basename(basePath);\n\n  // Split into stem and extension at the *last* dot.\n  const dotIndex = fullName.lastIndexOf(\".\");\n  let stem: string;\n  let ext: string;\n  if (dotIndex > 0) {\n    stem = fullName.substring(0, dotIndex);\n    ext = fullName.substring(dotIndex);\n  } else {\n    stem = fullName;\n    ext = \"\";\n  }\n\n  for (let i = 1; i <= MAX_CONFLICT_ATTEMPTS; i++) {\n    const candidate = `${stem} (${i})${ext}`;\n    const candidatePath = GLib.build_filenamev([dir, candidate]);\n    if (!Gio.File.new_for_path(candidatePath).query_exists(null)) {\n      return candidatePath;\n    }\n  }\n\n  throw new Error(\n    `Could not find an available filename after ${MAX_CONFLICT_ATTEMPTS} attempts: ${basePath}`,\n  );\n}\n\n/**\n * Determine the output path for an encryption operation.\n *\n * The default behaviour is to append {@link EXTENSION} to the input\n * filename. If `outputDir` is provided the result is placed there\n * instead of alongside the input file.\n *\n * When the computed path already exists, a numeric suffix is appended\n * automatically (e.g. `photo.jpg (1).gtkrypt`).\n *\n * @param inputPath - Absolute path to the plaintext input file.\n * @param outputDir - Optional directory override for the output file.\n * @returns An absolute path that does not yet exist on disk.\n */\nexport function getEncryptOutputPath(\n  inputPath: string,\n  outputDir?: string,\n): string {\n  const baseName = GLib.path_get_basename(inputPath) + EXTENSION;\n\n  const dir =\n    outputDir !== undefined ? outputDir : GLib.path_get_dirname(inputPath);\n\n  const outputPath = GLib.build_filenamev([dir, baseName]);\n\n  if (!Gio.File.new_for_path(outputPath).query_exists(null)) {\n    return outputPath;\n  }\n\n  return resolveConflict(outputPath);\n}\n\n/**\n * Determine the output path for a decryption operation.\n *\n * The filename is chosen using the following priority:\n *   1. `storedFilename` from the container header (if non-empty).\n *   2. The input filename with the `.gtkrypt` extension stripped.\n *   3. A timestamped fallback: `Decrypted - 2025-01-15T10-30-00-000Z`.\n *\n * If `outputDir` is provided the result is placed there instead of\n * alongside the input file.\n *\n * When the computed path already exists, a numeric suffix is appended\n * automatically (e.g. `photo (1).jpg`).\n *\n * @param inputPath - Absolute path to the encrypted input file.\n * @param storedFilename - Optional original filename stored in the container.\n * @param outputDir - Optional directory override for the output file.\n * @returns An absolute path that does not yet exist on disk.\n */\nexport function getDecryptOutputPath(\n  inputPath: string,\n  storedFilename?: string,\n  outputDir?: string,\n): string {\n  let baseName: string;\n\n  if (storedFilename !== undefined && storedFilename.length > 0) {\n    baseName = storedFilename;\n  } else {\n    const inputName = GLib.path_get_basename(inputPath);\n    if (inputName.endsWith(EXTENSION)) {\n      baseName = inputName.substring(0, inputName.length - EXTENSION.length);\n    } else {\n      const stamp = new Date().toISOString().replace(/[:.]/g, \"-\");\n      baseName = `Decrypted - ${stamp}`;\n    }\n  }\n\n  const dir =\n    outputDir !== undefined ? outputDir : GLib.path_get_dirname(inputPath);\n\n  const outputPath = GLib.build_filenamev([dir, baseName]);\n\n  if (!Gio.File.new_for_path(outputPath).query_exists(null)) {\n    return outputPath;\n  }\n\n  return resolveConflict(outputPath);\n}\n", "/**\n * Unit tests for the output naming service.\n *\n * Tests encrypt/decrypt path generation, conflict resolution,\n * custom output directories, and fallback naming behaviour.\n *\n * Uses real temp directories so that `Gio.File.query_exists()`\n * and `GLib.path_get_dirname/basename/build_filenamev` work as\n * they would in the actual application.\n */\n\nimport { assertEqual, assert, report } from \"../../tests/harness.js\";\nimport {\n  getEncryptOutputPath,\n  getDecryptOutputPath,\n  EXTENSION,\n} from \"../../src/services/naming.js\";\nimport GLib from \"gi://GLib\";\nimport Gio from \"gi://Gio\";\n\n// ---------------------------------------------------------------------------\n// Helpers\n// ---------------------------------------------------------------------------\n\n/** Create a temp directory for test isolation. */\nfunction makeTmpDir(): string {\n  return GLib.dir_make_tmp(\"gtkrypt-naming-XXXXXX\");\n}\n\n/** Create an empty file at `path` so it \"exists\" for conflict checks. */\nfunction touchFile(path: string): void {\n  const file = Gio.File.new_for_path(path);\n  const stream = file.create(Gio.FileCreateFlags.NONE, null);\n  stream.close(null);\n}\n\n/** Recursively remove a directory and its contents. */\nfunction rmDir(dirPath: string): void {\n  const dir = Gio.File.new_for_path(dirPath);\n  const enumerator = dir.enumerate_children(\n    \"standard::name,standard::type\",\n    Gio.FileQueryInfoFlags.NOFOLLOW_SYMLINKS,\n    null,\n  );\n\n  let info = enumerator.next_file(null);\n  while (info !== null) {\n    const child = enumerator.get_child(info);\n    const fileType = info.get_file_type();\n    if (fileType === Gio.FileType.DIRECTORY) {\n      rmDir(child.get_path()!);\n    } else {\n      child.delete(null);\n    }\n    info = enumerator.next_file(null);\n  }\n  enumerator.close(null);\n  dir.delete(null);\n}\n\n// ---------------------------------------------------------------------------\n// Tests\n// ---------------------------------------------------------------------------\n\nconst tmpDir = makeTmpDir();\n\ntry {\n  // --- 1. Basic encrypt naming ---\n  {\n    const inputPath = GLib.build_filenamev([tmpDir, \"photo.jpg\"]);\n    touchFile(inputPath);\n\n    const result = getEncryptOutputPath(inputPath);\n    const expected = GLib.build_filenamev([tmpDir, \"photo.jpg.gtkrypt\"]);\n\n    assertEqual(result, expected, \"basic encrypt: photo.jpg -> photo.jpg.gtkrypt\");\n  }\n\n  // --- 2. Conflict resolution (encrypt) ---\n  {\n    const inputPath = GLib.build_filenamev([tmpDir, \"photo.jpg\"]);\n    // photo.jpg already exists from test 1.\n    // Create the default output so it conflicts.\n    const conflicting = GLib.build_filenamev([tmpDir, \"photo.jpg.gtkrypt\"]);\n    touchFile(conflicting);\n\n    const result = getEncryptOutputPath(inputPath);\n    const expected = GLib.build_filenamev([tmpDir, \"photo.jpg (1).gtkrypt\"]);\n\n    assertEqual(result, expected, \"conflict resolution: photo.jpg (1).gtkrypt\");\n  }\n\n  // --- 2b. Double conflict resolution ---\n  {\n    // photo.jpg.gtkrypt and photo.jpg (1).gtkrypt both exist now; create (1).\n    const existing1 = GLib.build_filenamev([tmpDir, \"photo.jpg (1).gtkrypt\"]);\n    touchFile(existing1);\n\n    const inputPath = GLib.build_filenamev([tmpDir, \"photo.jpg\"]);\n    const result = getEncryptOutputPath(inputPath);\n    const expected = GLib.build_filenamev([tmpDir, \"photo.jpg (2).gtkrypt\"]);\n\n    assertEqual(result, expected, \"double conflict: photo.jpg (2).gtkrypt\");\n  }\n\n  // --- 3. Basic decrypt naming ---\n  {\n    const inputPath = GLib.build_filenamev([tmpDir, \"photo.jpg.gtkrypt\"]);\n    // File was created in test 2, so it exists on disk (not strictly required\n    // for getDecryptOutputPath, but keeps the scenario realistic).\n\n    const result = getDecryptOutputPath(inputPath);\n\n    // photo.jpg already exists (from test 1), so conflict resolution kicks in.\n    // Use a fresh subdir to avoid that interference.\n    const subDir = GLib.build_filenamev([tmpDir, \"decrypt-basic\"]);\n    GLib.mkdir_with_parents(subDir, 0o755);\n\n    const freshInput = GLib.build_filenamev([subDir, \"photo.jpg.gtkrypt\"]);\n    touchFile(freshInput);\n\n    const freshResult = getDecryptOutputPath(freshInput);\n    const expected = GLib.build_filenamev([subDir, \"photo.jpg\"]);\n\n    assertEqual(freshResult, expected, \"basic decrypt: photo.jpg.gtkrypt -> photo.jpg\");\n  }\n\n  // --- 4. Decrypt with stored filename ---\n  {\n    const subDir = GLib.build_filenamev([tmpDir, \"decrypt-stored\"]);\n    GLib.mkdir_with_parents(subDir, 0o755);\n\n    const inputPath = GLib.build_filenamev([subDir, \"data.gtkrypt\"]);\n    touchFile(inputPath);\n\n    const result = getDecryptOutputPath(inputPath, \"report.pdf\");\n    const expected = GLib.build_filenamev([subDir, \"report.pdf\"]);\n\n    assertEqual(result, expected, \"decrypt with stored filename: report.pdf\");\n  }\n\n  // --- 4b. Stored filename ignored when empty string ---\n  {\n    const subDir = GLib.build_filenamev([tmpDir, \"decrypt-empty-stored\"]);\n    GLib.mkdir_with_parents(subDir, 0o755);\n\n    const inputPath = GLib.build_filenamev([subDir, \"notes.txt.gtkrypt\"]);\n    touchFile(inputPath);\n\n    const result = getDecryptOutputPath(inputPath, \"\");\n    const expected = GLib.build_filenamev([subDir, \"notes.txt\"]);\n\n    assertEqual(result, expected, \"empty stored filename falls back to extension strip\");\n  }\n\n  // --- 5. Decrypt without .gtkrypt extension (timestamp fallback) ---\n  {\n    const subDir = GLib.build_filenamev([tmpDir, \"decrypt-fallback\"]);\n    GLib.mkdir_with_parents(subDir, 0o755);\n\n    const inputPath = GLib.build_filenamev([subDir, \"mystery\"]);\n    touchFile(inputPath);\n\n    const result = getDecryptOutputPath(inputPath);\n\n    assert(\n      result.startsWith(subDir + \"/Decrypted - \"),\n      \"fallback starts with 'Decrypted - '\",\n    );\n    assert(\n      !result.endsWith(EXTENSION),\n      \"fallback does not have .gtkrypt extension\",\n    );\n    // Verify the timestamp portion looks like an ISO-ish date (YYYY-MM-DD...).\n    const basename = GLib.path_get_basename(result);\n    const stampPart = basename.replace(\"Decrypted - \", \"\");\n    assert(\n      /^\\d{4}-\\d{2}-\\d{2}T\\d{2}-\\d{2}-\\d{2}-\\d{3}Z$/.test(stampPart),\n      `fallback timestamp format valid: ${stampPart}`,\n    );\n  }\n\n  // --- 6. Custom output directory (encrypt) ---\n  {\n    const srcDir = GLib.build_filenamev([tmpDir, \"custom-src\"]);\n    const outDir = GLib.build_filenamev([tmpDir, \"custom-out\"]);\n    GLib.mkdir_with_parents(srcDir, 0o755);\n    GLib.mkdir_with_parents(outDir, 0o755);\n\n    const inputPath = GLib.build_filenamev([srcDir, \"secret.doc\"]);\n    touchFile(inputPath);\n\n    const result = getEncryptOutputPath(inputPath, outDir);\n    const expected = GLib.build_filenamev([outDir, \"secret.doc.gtkrypt\"]);\n\n    assertEqual(result, expected, \"custom output dir (encrypt): placed in outDir\");\n    assertEqual(\n      GLib.path_get_dirname(result),\n      outDir,\n      \"custom output dir (encrypt): dirname matches outDir\",\n    );\n  }\n\n  // --- 6b. Custom output directory (decrypt) ---\n  {\n    const srcDir = GLib.build_filenamev([tmpDir, \"custom-dec-src\"]);\n    const outDir = GLib.build_filenamev([tmpDir, \"custom-dec-out\"]);\n    GLib.mkdir_with_parents(srcDir, 0o755);\n    GLib.mkdir_with_parents(outDir, 0o755);\n\n    const inputPath = GLib.build_filenamev([srcDir, \"archive.tar.gtkrypt\"]);\n    touchFile(inputPath);\n\n    const result = getDecryptOutputPath(inputPath, undefined, outDir);\n    const expected = GLib.build_filenamev([outDir, \"archive.tar\"]);\n\n    assertEqual(result, expected, \"custom output dir (decrypt): placed in outDir\");\n    assertEqual(\n      GLib.path_get_dirname(result),\n      outDir,\n      \"custom output dir (decrypt): dirname matches outDir\",\n    );\n  }\n\n  // --- 6c. Custom output directory with conflict ---\n  {\n    const srcDir = GLib.build_filenamev([tmpDir, \"custom-conflict-src\"]);\n    const outDir = GLib.build_filenamev([tmpDir, \"custom-conflict-out\"]);\n    GLib.mkdir_with_parents(srcDir, 0o755);\n    GLib.mkdir_with_parents(outDir, 0o755);\n\n    const inputPath = GLib.build_filenamev([srcDir, \"data.bin\"]);\n    touchFile(inputPath);\n\n    // Create conflict in the output dir\n    const conflicting = GLib.build_filenamev([outDir, \"data.bin.gtkrypt\"]);\n    touchFile(conflicting);\n\n    const result = getEncryptOutputPath(inputPath, outDir);\n    const expected = GLib.build_filenamev([outDir, \"data.bin (1).gtkrypt\"]);\n\n    assertEqual(\n      result,\n      expected,\n      \"custom output dir with conflict: data.bin (1).gtkrypt\",\n    );\n  }\n\n  // --- 7. Decrypt conflict resolution ---\n  {\n    const subDir = GLib.build_filenamev([tmpDir, \"decrypt-conflict\"]);\n    GLib.mkdir_with_parents(subDir, 0o755);\n\n    const inputPath = GLib.build_filenamev([subDir, \"readme.md.gtkrypt\"]);\n    touchFile(inputPath);\n\n    // Create the plain output file so it conflicts\n    const existing = GLib.build_filenamev([subDir, \"readme.md\"]);\n    touchFile(existing);\n\n    const result = getDecryptOutputPath(inputPath);\n    const expected = GLib.build_filenamev([subDir, \"readme (1).md\"]);\n\n    assertEqual(result, expected, \"decrypt conflict: readme (1).md\");\n  }\n\n  // --- 8. EXTENSION constant ---\n  {\n    assertEqual(EXTENSION, \".gtkrypt\", \"EXTENSION constant is .gtkrypt\");\n  }\n} finally {\n  // Clean up temp directory regardless of test outcome.\n  rmDir(tmpDir);\n}\n\nreport(\"naming\");\n"],
  "mappings": "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",
  "names": ["GLib", "Gio"]
}

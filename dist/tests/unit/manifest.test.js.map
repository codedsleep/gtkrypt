{
  "version": 3,
  "sources": ["../../../tests/harness.ts", "../../../src/services/manifest.ts", "../../../src/models/categories.ts", "../../../src/util/i18n.ts", "../../../src/models/errors.ts", "../../../src/services/crypto.ts", "../../../src/util/logging.ts", "../../../tests/unit/manifest.test.ts"],
  "sourcesContent": ["/**\n * Minimal GJS test harness with assertion helpers.\n *\n * Each test file imports from this module, runs assertions, and\n * calls `report()` at the end. Non-zero exit on any failure.\n */\n\nlet _passed = 0;\nlet _failed = 0;\nconst _errors: string[] = [];\n\nexport function assert(condition: boolean, message: string): void {\n  if (condition) {\n    _passed++;\n  } else {\n    _failed++;\n    _errors.push(`  FAIL: ${message}`);\n  }\n}\n\nexport function assertEqual<T>(actual: T, expected: T, message: string): void {\n  if (actual === expected) {\n    _passed++;\n  } else {\n    _failed++;\n    _errors.push(`  FAIL: ${message}\\n    expected: ${String(expected)}\\n    actual:   ${String(actual)}`);\n  }\n}\n\nexport function assertDeepEqual(actual: Uint8Array, expected: Uint8Array, message: string): void {\n  if (actual.length !== expected.length) {\n    _failed++;\n    _errors.push(`  FAIL: ${message}\\n    length mismatch: expected ${expected.length}, got ${actual.length}`);\n    return;\n  }\n  for (let i = 0; i < actual.length; i++) {\n    if (actual[i] !== expected[i]) {\n      _failed++;\n      _errors.push(`  FAIL: ${message}\\n    byte ${i} differs: expected ${expected[i]}, got ${actual[i]}`);\n      return;\n    }\n  }\n  _passed++;\n}\n\nexport function assertThrows(fn: () => void, errorName: string, message: string): void {\n  try {\n    fn();\n    _failed++;\n    _errors.push(`  FAIL: ${message}\\n    expected ${errorName} to be thrown, but nothing was thrown`);\n  } catch (e: unknown) {\n    const err = e as { name?: string };\n    if (err.name === errorName) {\n      _passed++;\n    } else {\n      _failed++;\n      _errors.push(`  FAIL: ${message}\\n    expected ${errorName}, got ${err.name ?? String(e)}`);\n    }\n  }\n}\n\nexport function assertBigIntEqual(actual: bigint, expected: bigint, message: string): void {\n  if (actual === expected) {\n    _passed++;\n  } else {\n    _failed++;\n    _errors.push(`  FAIL: ${message}\\n    expected: ${String(expected)}\\n    actual:   ${String(actual)}`);\n  }\n}\n\nexport function report(suiteName: string): void {\n  if (_errors.length > 0) {\n    printerr(`\\n${suiteName}:`);\n    for (const err of _errors) {\n      printerr(err);\n    }\n  }\n  print(`${suiteName}: ${_passed} passed, ${_failed} failed`);\n  if (_failed > 0) {\n    imports.system.exit(1);\n  }\n}\n", "/**\n * Vault manifest service.\n *\n * Handles creation, serialization, encryption, and decryption of\n * the vault manifest \u2014 the encrypted JSON file that tracks all\n * items, categories, and settings for a vault.\n */\n\nimport GLib from \"gi://GLib\";\nimport Gio from \"gi://Gio\";\n\nimport type { VaultManifest, KdfPreset } from \"../models/types.js\";\nimport { DEFAULT_CATEGORIES } from \"../models/categories.js\";\nimport {\n  VaultCorruptError,\n  ManifestConcurrentModificationError,\n} from \"../models/errors.js\";\nimport { encryptBuffer, decryptToBuffer } from \"./crypto.js\";\nimport { _ } from \"../util/i18n.js\";\n\n/**\n * Create a new empty manifest with default settings.\n *\n * @param name - Vault display name.\n * @param kdfPreset - KDF strength preset for the vault.\n * @returns A fresh VaultManifest ready to be saved.\n */\nexport function createEmptyManifest(\n  name: string,\n  kdfPreset: KdfPreset,\n): VaultManifest {\n  const now = new Date().toISOString();\n  return {\n    version: 1,\n    name,\n    createdAt: now,\n    modifiedAt: now,\n    kdfPreset,\n    categories: [...DEFAULT_CATEGORIES],\n    items: [],\n    settings: {\n      autoLockMinutes: 5,\n      defaultCategory: \"other\",\n      sortOrder: \"date\",\n      viewMode: \"list\",\n    },\n  };\n}\n\n/**\n * Serialize a manifest to a JSON byte buffer.\n *\n * @param manifest - The manifest to serialize.\n * @returns UTF-8 encoded JSON bytes.\n */\nexport function serializeManifest(manifest: VaultManifest): Uint8Array {\n  const json = JSON.stringify(manifest, null, 2);\n  return new TextEncoder().encode(json);\n}\n\n/**\n * Deserialize a manifest from a JSON byte buffer.\n *\n * @param bytes - UTF-8 encoded JSON bytes.\n * @returns The parsed manifest.\n * @throws {@link VaultCorruptError} if the data is not valid manifest JSON.\n */\nexport function deserializeManifest(bytes: Uint8Array): VaultManifest {\n  try {\n    const json = new TextDecoder().decode(bytes);\n    const manifest = JSON.parse(json) as VaultManifest;\n\n    if (manifest.version !== 1) {\n      throw new VaultCorruptError(\n        `Unsupported manifest version: ${manifest.version}`,\n        _(\"Unsupported vault version. Try updating gtkrypt to the latest version.\"),\n      );\n    }\n\n    return manifest;\n  } catch (e) {\n    if (e instanceof VaultCorruptError) throw e;\n    throw new VaultCorruptError(\n      `Failed to parse vault manifest: ${e}`,\n      _(\"The vault manifest is corrupted. Try restoring from a backup.\"),\n    );\n  }\n}\n\n/**\n * Get the modification time of the manifest file.\n *\n * @param vaultDir - Absolute path to the vault directory.\n * @returns Modification time in seconds since epoch, or 0 if not found.\n */\nexport function getManifestMtime(vaultDir: string): number {\n  const manifestPath = GLib.build_filenamev([vaultDir, \"manifest.gtkrypt\"]);\n  const file = Gio.File.new_for_path(manifestPath);\n  try {\n    const info = file.query_info(\n      \"time::modified\",\n      Gio.FileQueryInfoFlags.NONE,\n      null,\n    );\n    return info.get_modification_date_time()?.to_unix() ?? 0;\n  } catch {\n    return 0;\n  }\n}\n\n/**\n * Encrypt and save a manifest to disk using atomic write.\n *\n * Writes to a temporary file first, then renames to the final path.\n * Optionally checks for concurrent modification via mtime.\n *\n * @param vaultDir - Absolute path to the vault directory.\n * @param manifest - The manifest to save.\n * @param passphrase - Vault passphrase for encryption.\n * @param expectedMtime - If provided, checks that manifest hasn't been modified since this time.\n * @returns The new modification time of the saved manifest.\n * @throws {@link ManifestConcurrentModificationError} if mtime doesn't match.\n */\nexport async function saveManifest(\n  vaultDir: string,\n  manifest: VaultManifest,\n  passphrase: string,\n  expectedMtime?: number,\n  keyfilePath?: string,\n): Promise<number> {\n  const outputPath = GLib.build_filenamev([vaultDir, \"manifest.gtkrypt\"]);\n\n  // Check for concurrent modification before writing.\n  if (expectedMtime !== undefined && expectedMtime > 0) {\n    const currentMtime = getManifestMtime(vaultDir);\n    if (currentMtime > 0 && currentMtime !== expectedMtime) {\n      throw new ManifestConcurrentModificationError();\n    }\n  }\n\n  // Atomic write: encrypt to temp file, then rename.\n  const tmpPath = outputPath + \".tmp\";\n  const bytes = serializeManifest(manifest);\n  await encryptBuffer(bytes, tmpPath, passphrase, {\n    storeFilename: false,\n    wipeOriginal: false,\n    kdfPreset: manifest.kdfPreset,\n  }, keyfilePath);\n\n  const tmpFile = Gio.File.new_for_path(tmpPath);\n  const destFile = Gio.File.new_for_path(outputPath);\n  tmpFile.move(destFile, Gio.FileCopyFlags.OVERWRITE, null, null);\n\n  return getManifestMtime(vaultDir);\n}\n\n/**\n * Load and decrypt a manifest from disk.\n *\n * @param vaultDir - Absolute path to the vault directory.\n * @param passphrase - Vault passphrase for decryption.\n * @returns The decrypted manifest and the file's modification time.\n */\nexport async function loadManifest(\n  vaultDir: string,\n  passphrase: string,\n  keyfilePath?: string,\n): Promise<{ manifest: VaultManifest; mtime: number }> {\n  const inputPath = GLib.build_filenamev([vaultDir, \"manifest.gtkrypt\"]);\n  const mtime = getManifestMtime(vaultDir);\n  const bytes = await decryptToBuffer(inputPath, passphrase, keyfilePath);\n  return { manifest: deserializeManifest(bytes), mtime };\n}\n", "/**\n * Default category definitions for vault items.\n *\n * Built-in categories cannot be deleted by the user. Custom categories\n * can be added through the category manager UI.\n */\n\nimport type { CategoryDef } from \"./types.js\";\n\n/** Default set of built-in vault categories. */\nexport const DEFAULT_CATEGORIES: CategoryDef[] = [\n  { id: \"identity\", label: \"Identity Documents\", icon: \"contact-new-symbolic\", builtin: true },\n  { id: \"banking\", label: \"Banking & Finance\", icon: \"wallet-symbolic\", builtin: true },\n  { id: \"medical\", label: \"Medical Records\", icon: \"heart-filled-symbolic\", builtin: true },\n  { id: \"insurance\", label: \"Insurance\", icon: \"shield-safe-symbolic\", builtin: true },\n  { id: \"legal\", label: \"Legal Documents\", icon: \"text-x-generic-symbolic\", builtin: true },\n  { id: \"education\", label: \"Education\", icon: \"school-symbolic\", builtin: true },\n  { id: \"travel\", label: \"Travel\", icon: \"airplane-symbolic\", builtin: true },\n  { id: \"property\", label: \"Property & Housing\", icon: \"building-symbolic\", builtin: true },\n  { id: \"vehicle\", label: \"Vehicles\", icon: \"car-symbolic\", builtin: true },\n  { id: \"other\", label: \"Other\", icon: \"folder-symbolic\", builtin: true },\n];\n", "import GLib from \"gi://GLib\";\n\nconst domain = \"gtkrypt\";\n\nimports.gettext.bindtextdomain(domain, GLib.get_home_dir());\nimports.gettext.textdomain(domain);\n\nexport const _ = imports.gettext.gettext;\nexport const ngettext = imports.gettext.ngettext;\n", "/**\n * Typed error classes for gtkrypt.\n *\n * Every error that can surface to the user has a `userMessage` property\n * containing a human-readable string suitable for display in the UI.\n * The `name` property is set to the class name for reliable `instanceof`\n * checks and clear stack traces.\n */\n\nimport { _ } from \"../util/i18n.js\";\n\n/** Base error class for all gtkrypt errors. */\nexport class GtkryptError extends Error {\n  public readonly userMessage: string;\n\n  constructor(message: string, userMessage: string) {\n    super(message);\n    this.name = \"GtkryptError\";\n    this.userMessage = userMessage;\n  }\n}\n\n/** The passphrase did not match or the file integrity check failed. */\nexport class WrongPassphraseError extends GtkryptError {\n  constructor(message = \"Wrong passphrase or integrity check failed\") {\n    super(message, _(\"Incorrect passphrase or file corrupted.\"));\n    this.name = \"WrongPassphraseError\";\n  }\n}\n\n/** The file is not a valid `.gtkrypt` container or has been corrupted. */\nexport class CorruptFileError extends GtkryptError {\n  constructor(message = \"Corrupt or unrecognized file format\") {\n    super(message, _(\"Not a gtkrypt file or file is corrupted.\"));\n    this.name = \"CorruptFileError\";\n  }\n}\n\n/** The container version is newer than this build understands. */\nexport class UnsupportedVersionError extends GtkryptError {\n  constructor(message = \"Unsupported container version\") {\n    super(message, _(\"This file was created with a newer version of gtkrypt.\"));\n    this.name = \"UnsupportedVersionError\";\n  }\n}\n\n/** The application lacks write permission to the target directory. */\nexport class PermissionError extends GtkryptError {\n  constructor(message = \"Permission denied\") {\n    super(message, _(\"No permission to write to the target directory.\"));\n    this.name = \"PermissionError\";\n  }\n}\n\n/** The user cancelled the operation. This is a silent error. */\nexport class CancelledError extends GtkryptError {\n  constructor(message = \"Operation cancelled\") {\n    super(message, \"\");\n    this.name = \"CancelledError\";\n  }\n}\n\n/** An unexpected internal error in the crypto backend. */\nexport class InternalCryptoError extends GtkryptError {\n  constructor(message = \"Internal crypto error\") {\n    super(message, _(\"An internal error occurred. Please report this bug.\"));\n    this.name = \"InternalCryptoError\";\n  }\n}\n\n// ---------------------------------------------------------------------------\n// Vault errors\n// ---------------------------------------------------------------------------\n\n/** Operation attempted while vault is locked. */\nexport class VaultLockedError extends GtkryptError {\n  constructor(message = \"Vault is locked\") {\n    super(message, _(\"The vault is locked. Please unlock it first.\"));\n    this.name = \"VaultLockedError\";\n  }\n}\n\n/** Vault directory does not exist. */\nexport class VaultNotFoundError extends GtkryptError {\n  constructor(message = \"Vault not found\") {\n    super(message, _(\"Vault not found.\"));\n    this.name = \"VaultNotFoundError\";\n  }\n}\n\n/** Manifest failed to parse after decryption. */\nexport class VaultCorruptError extends GtkryptError {\n  constructor(message = \"Vault data is corrupted\", userMessage?: string) {\n    super(message, userMessage ?? _(\"The vault data is corrupted.\"));\n    this.name = \"VaultCorruptError\";\n  }\n}\n\n/** An item's encrypted file is missing from the vault directory. */\nexport class ItemFileMissingError extends GtkryptError {\n  constructor(message = \"Item file is missing from vault\") {\n    super(\n      message,\n      _(\"Item file is missing from vault. The item may be corrupted.\"),\n    );\n    this.name = \"ItemFileMissingError\";\n  }\n}\n\n/** The manifest was modified externally since last load/save. */\nexport class ManifestConcurrentModificationError extends GtkryptError {\n  constructor(message = \"Manifest was modified externally\") {\n    super(\n      message,\n      _(\"The vault was modified externally. Please lock and re-unlock to reload.\"),\n    );\n    this.name = \"ManifestConcurrentModificationError\";\n  }\n}\n\n/** Item UUID not found in manifest. */\nexport class ItemNotFoundError extends GtkryptError {\n  constructor(message = \"Item not found in vault\") {\n    super(message, _(\"Item not found in vault.\"));\n    this.name = \"ItemNotFoundError\";\n  }\n}\n\n/** Vault with same name already exists. */\nexport class DuplicateVaultError extends GtkryptError {\n  constructor(message = \"A vault with this name already exists\") {\n    super(message, _(\"A vault with this name already exists.\"));\n    this.name = \"DuplicateVaultError\";\n  }\n}\n", "/**\n * Crypto bridge service -- spawns the Rust `gtkrypt-crypto` binary.\n *\n * All encryption and decryption is delegated to the Rust subprocess.\n * Communication follows a simple protocol:\n *   - The passphrase is written to the subprocess's stdin (one line).\n *   - Progress events are emitted on stdout as newline-delimited JSON.\n *   - The exit code indicates success (0) or a classified error.\n *\n * This module never handles raw key material -- only the passphrase\n * is forwarded to the binary, and it is not logged.\n */\n\nimport Gio from \"gi://Gio\";\nimport GLib from \"gi://GLib\";\n\nimport type {\n  CryptoResult,\n  EncryptOptions,\n  DecryptOptions,\n  ProgressEvent,\n} from \"../models/types.js\";\nimport { KDF_PRESETS } from \"../models/types.js\";\nimport {\n  WrongPassphraseError,\n  CorruptFileError,\n  PermissionError,\n  CancelledError,\n  InternalCryptoError,\n  GtkryptError,\n} from \"../models/errors.js\";\nimport { log } from \"../util/logging.js\";\n\n// ---------------------------------------------------------------------------\n// Binary discovery\n// ---------------------------------------------------------------------------\n\n/**\n * Locate the `gtkrypt-crypto` binary on the filesystem.\n *\n * Searches in the following order:\n *   1. Development build path relative to the running script.\n *   2. Installed alongside the main script.\n *   3. Anywhere on $PATH.\n *\n * @returns Absolute path to the binary.\n * @throws {@link InternalCryptoError} if the binary cannot be found.\n */\nfunction findCryptoBinary(): string {\n  const selfDir = GLib.path_get_dirname(imports.system.programInvocationName);\n\n  // 1. Development path: <project>/crypto/target/release/gtkrypt-crypto\n  const devPath = GLib.build_filenamev([\n    selfDir,\n    \"..\",\n    \"crypto\",\n    \"target\",\n    \"release\",\n    \"gtkrypt-crypto\",\n  ]);\n  if (GLib.file_test(devPath, GLib.FileTest.IS_EXECUTABLE)) {\n    log(\"debug\", `Found crypto binary (dev): ${devPath}`);\n    return devPath;\n  }\n\n  // 2. Installed alongside the main binary\n  const siblingPath = GLib.build_filenamev([selfDir, \"gtkrypt-crypto\"]);\n  if (GLib.file_test(siblingPath, GLib.FileTest.IS_EXECUTABLE)) {\n    log(\"debug\", `Found crypto binary (sibling): ${siblingPath}`);\n    return siblingPath;\n  }\n\n  // 3. Search $PATH\n  const pathResult = GLib.find_program_in_path(\"gtkrypt-crypto\");\n  if (pathResult !== null) {\n    log(\"debug\", `Found crypto binary (PATH): ${pathResult}`);\n    return pathResult;\n  }\n\n  throw new InternalCryptoError(\n    \"Could not locate the gtkrypt-crypto binary. \" +\n      \"Ensure it is built or installed correctly.\",\n  );\n}\n\n// ---------------------------------------------------------------------------\n// Exit-code error mapping\n// ---------------------------------------------------------------------------\n\n/**\n * Map a non-zero exit code from the Rust binary to a typed error.\n *\n * @param exitCode - Process exit code.\n * @param stderrText - First line of stderr output (may be empty).\n * @returns A {@link GtkryptError} subclass instance.\n */\nfunction mapExitCodeToError(\n  exitCode: number,\n  stderrText: string,\n): GtkryptError {\n  const detail = stderrText.length > 0 ? stderrText : `exit code ${exitCode}`;\n\n  switch (exitCode) {\n    case 1:\n      return new WrongPassphraseError(detail);\n    case 2:\n      return new CorruptFileError(detail);\n    case 3:\n      return new PermissionError(detail);\n    case 10:\n      return new InternalCryptoError(detail);\n    default:\n      return new InternalCryptoError(\n        `Unexpected crypto exit code ${exitCode}: ${detail}`,\n      );\n  }\n}\n\n// ---------------------------------------------------------------------------\n// Progress line reader\n// ---------------------------------------------------------------------------\n\n/**\n * Read newline-delimited JSON progress events from stdout.\n *\n * Each line is expected to be a JSON object:\n * ```json\n * {\"progress\":0.5,\"bytes_processed\":1024,\"total_bytes\":2048,\"phase\":\"encrypt\"}\n * ```\n *\n * Malformed lines are silently ignored (the Rust binary may emit\n * debug messages on stdout in development builds).\n *\n * This function reads synchronously on the GLib main context via\n * `read_line_utf8`, which is appropriate because the subprocess\n * drives the pace of output and we process it in the async callback\n * pipeline initiated by `wait_async`.\n *\n * @param dataStream - DataInputStream wrapping the subprocess stdout.\n * @param onProgress - Callback to invoke for each parsed event.\n * @param cancellable - Optional cancellable to abort reading.\n */\nfunction readProgressLines(\n  dataStream: Gio.DataInputStream,\n  onProgress: ((event: ProgressEvent) => void) | undefined,\n  cancellable: Gio.Cancellable | null,\n): void {\n  if (onProgress === undefined) {\n    // Nothing to do -- close the stream so the subprocess is not blocked.\n    try {\n      dataStream.close(null);\n    } catch {\n      // Ignore close errors.\n    }\n    return;\n  }\n\n  // After the guard above, onProgress is guaranteed to be defined.\n  const emit = onProgress!;\n\n  /**\n   * Recursively schedule async line reads so that the GLib main loop\n   * is not blocked.  Each completed read triggers the next until EOF.\n   */\n  function readNext(): void {\n    dataStream.read_line_async(\n      GLib.PRIORITY_DEFAULT,\n      cancellable,\n      (_stream, result) => {\n        try {\n          const [line] = dataStream.read_line_finish_utf8(result);\n\n          if (line === null) {\n            // EOF reached -- subprocess has closed stdout.\n            try {\n              dataStream.close(null);\n            } catch {\n              // Ignore.\n            }\n            return;\n          }\n\n          try {\n            const parsed = JSON.parse(line) as {\n              progress?: number;\n              bytes_processed?: number;\n              total_bytes?: number;\n              phase?: string;\n            };\n\n            if (\n              typeof parsed.bytes_processed === \"number\" &&\n              typeof parsed.total_bytes === \"number\" &&\n              typeof parsed.phase === \"string\"\n            ) {\n              emit({\n                fileIndex: 0,\n                bytesProcessed: parsed.bytes_processed,\n                totalBytes: parsed.total_bytes,\n                phase: parsed.phase as ProgressEvent[\"phase\"],\n              });\n            }\n          } catch {\n            // Malformed JSON -- skip this line.\n          }\n\n          // Schedule next line read.\n          readNext();\n        } catch {\n          // Stream read failed (possibly cancelled). Stop reading.\n          try {\n            dataStream.close(null);\n          } catch {\n            // Ignore.\n          }\n        }\n      },\n    );\n  }\n\n  readNext();\n}\n\n// ---------------------------------------------------------------------------\n// Encrypt\n// ---------------------------------------------------------------------------\n\n/**\n * Encrypt a file using the Rust crypto backend.\n *\n * @param inputPath - Absolute path to the plaintext input file.\n * @param outputPath - Absolute path for the resulting `.gtkrypt` file.\n * @param passphrase - User-supplied passphrase (not logged).\n * @param options - Encryption options including KDF preset.\n * @param onProgress - Optional callback for progress updates.\n * @param cancellable - Optional GIO cancellable to abort the operation.\n * @returns A promise resolving to a {@link CryptoResult} on success.\n */\nexport function encrypt(\n  inputPath: string,\n  outputPath: string,\n  passphrase: string,\n  options: EncryptOptions,\n  onProgress?: (event: ProgressEvent) => void,\n  cancellable?: Gio.Cancellable | null,\n  keyfilePath?: string,\n): Promise<CryptoResult> {\n  return new Promise<CryptoResult>((resolve, reject) => {\n    try {\n      const binaryPath = findCryptoBinary();\n      const params = KDF_PRESETS[options.kdfPreset];\n\n      const argv = [\n        binaryPath,\n        \"encrypt\",\n        \"--input\",\n        inputPath,\n        \"--output\",\n        outputPath,\n        \"--time-cost\",\n        String(params.timeCost),\n        \"--memory-cost\",\n        String(params.memoryCost),\n        \"--parallelism\",\n        String(params.parallelism),\n      ];\n\n      if (options.storeFilename) {\n        argv.push(\"--store-filename\");\n      }\n\n      if (keyfilePath) {\n        argv.push(\"--keyfile\", keyfilePath);\n      }\n\n      log(\"debug\", `Spawning encrypt: ${argv.join(\" \")}`);\n\n      const subprocess = new Gio.Subprocess({\n        argv: argv,\n        flags:\n          Gio.SubprocessFlags.STDIN_PIPE |\n          Gio.SubprocessFlags.STDOUT_PIPE |\n          Gio.SubprocessFlags.STDERR_PIPE,\n      });\n      subprocess.init(cancellable ?? null);\n\n      // Hook up cancellation to force-kill the subprocess.\n      let cancelledId = 0;\n      if (cancellable !== undefined && cancellable !== null) {\n        cancelledId = cancellable.connect(() => {\n          log(\"info\", \"Encrypt operation cancelled -- killing subprocess\");\n          subprocess.force_exit();\n        });\n      }\n\n      // Write the passphrase to stdin then close the pipe.\n      const stdinStream = subprocess.get_stdin_pipe()!;\n      const encoder = new TextEncoder();\n      const passphraseBytes = encoder.encode(passphrase + \"\\n\");\n      stdinStream.write_bytes(\n        new GLib.Bytes(passphraseBytes),\n        cancellable ?? null,\n      );\n      stdinStream.close(cancellable ?? null);\n\n      // Start reading progress from stdout.\n      const stdoutStream = new Gio.DataInputStream({\n        base_stream: subprocess.get_stdout_pipe()!,\n      });\n      readProgressLines(stdoutStream, onProgress, cancellable ?? null);\n\n      // Wait for the subprocess to exit.\n      subprocess.wait_async(cancellable ?? null, (_subprocess, result) => {\n        // Disconnect the cancellable handler to avoid double-signalling.\n        if (cancelledId > 0 && cancellable) {\n          cancellable.disconnect(cancelledId);\n        }\n\n        try {\n          subprocess.wait_finish(result);\n\n          if (subprocess.get_if_exited()) {\n            const exitCode = subprocess.get_exit_status();\n\n            if (exitCode === 0) {\n              log(\"info\", \"Encrypt completed successfully\");\n              resolve({ success: true, outputPath });\n              return;\n            }\n\n            // Read first line of stderr for the error detail.\n            const stderrStream = new Gio.DataInputStream({\n              base_stream: subprocess.get_stderr_pipe()!,\n            });\n            const [stderrText] = stderrStream.read_line_utf8(null);\n            stderrStream.close(null);\n\n            log(\"warn\", `Encrypt failed with exit code ${exitCode}`);\n            reject(mapExitCodeToError(exitCode, stderrText ?? \"\"));\n          } else {\n            // Process was killed by a signal.\n            if (cancellable?.is_cancelled()) {\n              reject(new CancelledError());\n            } else {\n              reject(\n                new InternalCryptoError(\n                  \"Crypto process terminated by signal\",\n                ),\n              );\n            }\n          }\n        } catch (e) {\n          if (cancellable?.is_cancelled()) {\n            reject(new CancelledError());\n          } else {\n            reject(new InternalCryptoError(String(e)));\n          }\n        }\n      });\n    } catch (e) {\n      if (cancellable?.is_cancelled()) {\n        reject(new CancelledError());\n      } else if (e instanceof GtkryptError) {\n        reject(e);\n      } else {\n        reject(new InternalCryptoError(String(e)));\n      }\n    }\n  });\n}\n\n// ---------------------------------------------------------------------------\n// Decrypt\n// ---------------------------------------------------------------------------\n\n/**\n * Decrypt a `.gtkrypt` file using the Rust crypto backend.\n *\n * @param inputPath - Absolute path to the encrypted `.gtkrypt` file.\n * @param outputPath - Absolute path for the decrypted output file.\n * @param passphrase - User-supplied passphrase (not logged).\n * @param _options - Decryption options (reserved for future use).\n * @param onProgress - Optional callback for progress updates.\n * @param cancellable - Optional GIO cancellable to abort the operation.\n * @returns A promise resolving to a {@link CryptoResult} on success.\n */\nexport function decrypt(\n  inputPath: string,\n  outputPath: string,\n  passphrase: string,\n  _options: DecryptOptions,\n  onProgress?: (event: ProgressEvent) => void,\n  cancellable?: Gio.Cancellable | null,\n  keyfilePath?: string,\n): Promise<CryptoResult> {\n  return new Promise<CryptoResult>((resolve, reject) => {\n    try {\n      const binaryPath = findCryptoBinary();\n\n      const argv = [\n        binaryPath,\n        \"decrypt\",\n        \"--input\",\n        inputPath,\n        \"--output\",\n        outputPath,\n      ];\n\n      if (keyfilePath) {\n        argv.push(\"--keyfile\", keyfilePath);\n      }\n\n      log(\"debug\", `Spawning decrypt: ${argv.join(\" \")}`);\n\n      const subprocess = new Gio.Subprocess({\n        argv: argv,\n        flags:\n          Gio.SubprocessFlags.STDIN_PIPE |\n          Gio.SubprocessFlags.STDOUT_PIPE |\n          Gio.SubprocessFlags.STDERR_PIPE,\n      });\n      subprocess.init(cancellable ?? null);\n\n      // Hook up cancellation to force-kill the subprocess.\n      let cancelledId = 0;\n      if (cancellable !== undefined && cancellable !== null) {\n        cancelledId = cancellable.connect(() => {\n          log(\"info\", \"Decrypt operation cancelled -- killing subprocess\");\n          subprocess.force_exit();\n        });\n      }\n\n      // Write the passphrase to stdin then close the pipe.\n      const stdinStream = subprocess.get_stdin_pipe()!;\n      const encoder = new TextEncoder();\n      const passphraseBytes = encoder.encode(passphrase + \"\\n\");\n      stdinStream.write_bytes(\n        new GLib.Bytes(passphraseBytes),\n        cancellable ?? null,\n      );\n      stdinStream.close(cancellable ?? null);\n\n      // Start reading progress from stdout.\n      const stdoutStream = new Gio.DataInputStream({\n        base_stream: subprocess.get_stdout_pipe()!,\n      });\n      readProgressLines(stdoutStream, onProgress, cancellable ?? null);\n\n      // Wait for the subprocess to exit.\n      subprocess.wait_async(cancellable ?? null, (_subprocess, result) => {\n        // Disconnect the cancellable handler to avoid double-signalling.\n        if (cancelledId > 0 && cancellable) {\n          cancellable.disconnect(cancelledId);\n        }\n\n        try {\n          subprocess.wait_finish(result);\n\n          if (subprocess.get_if_exited()) {\n            const exitCode = subprocess.get_exit_status();\n\n            if (exitCode === 0) {\n              log(\"info\", \"Decrypt completed successfully\");\n              resolve({ success: true, outputPath });\n              return;\n            }\n\n            // Read first line of stderr for the error detail.\n            const stderrStream = new Gio.DataInputStream({\n              base_stream: subprocess.get_stderr_pipe()!,\n            });\n            const [stderrText] = stderrStream.read_line_utf8(null);\n            stderrStream.close(null);\n\n            log(\"warn\", `Decrypt failed with exit code ${exitCode}`);\n            reject(mapExitCodeToError(exitCode, stderrText ?? \"\"));\n          } else {\n            // Process was killed by a signal.\n            if (cancellable?.is_cancelled()) {\n              reject(new CancelledError());\n            } else {\n              reject(\n                new InternalCryptoError(\n                  \"Crypto process terminated by signal\",\n                ),\n              );\n            }\n          }\n        } catch (e) {\n          if (cancellable?.is_cancelled()) {\n            reject(new CancelledError());\n          } else {\n            reject(new InternalCryptoError(String(e)));\n          }\n        }\n      });\n    } catch (e) {\n      if (cancellable?.is_cancelled()) {\n        reject(new CancelledError());\n      } else if (e instanceof GtkryptError) {\n        reject(e);\n      } else {\n        reject(new InternalCryptoError(String(e)));\n      }\n    }\n  });\n}\n\n// ---------------------------------------------------------------------------\n// In-memory buffer operations\n// ---------------------------------------------------------------------------\n\n/**\n * Encrypt an in-memory buffer to a `.gtkrypt` file.\n *\n * Writes the buffer to a temporary file, encrypts it to the output path,\n * then securely removes the temporary file. The temp file is always\n * cleaned up, even if encryption fails.\n *\n * @param data - The plaintext data to encrypt.\n * @param outputPath - Absolute path for the resulting `.gtkrypt` file.\n * @param passphrase - User-supplied passphrase.\n * @param options - Encryption options including KDF preset.\n * @returns A promise resolving to a {@link CryptoResult}.\n */\nexport async function encryptBuffer(\n  data: Uint8Array,\n  outputPath: string,\n  passphrase: string,\n  options: EncryptOptions,\n  keyfilePath?: string,\n): Promise<CryptoResult> {\n  const [fd, tempPath] = GLib.file_open_tmp(\"gtkrypt-XXXXXX\");\n  GLib.close(fd);\n\n  try {\n    // Write data to the temp file with restrictive permissions.\n    const tempFile = Gio.File.new_for_path(tempPath);\n    const stream = tempFile.replace(null, false, Gio.FileCreateFlags.PRIVATE, null);\n    if (data.length > 0) {\n      stream.write_bytes(new GLib.Bytes(data), null);\n    }\n    stream.close(null);\n\n    return await encrypt(tempPath, outputPath, passphrase, options, undefined, undefined, keyfilePath);\n  } finally {\n    try {\n      Gio.File.new_for_path(tempPath).delete(null);\n    } catch {\n      // Temp file may already be gone.\n    }\n  }\n}\n\n/**\n * Decrypt a `.gtkrypt` file to an in-memory buffer.\n *\n * Decrypts to a temporary file, reads the contents into memory,\n * then securely removes the temporary file. The temp file is always\n * cleaned up, even if decryption fails.\n *\n * @param inputPath - Absolute path to the encrypted `.gtkrypt` file.\n * @param passphrase - User-supplied passphrase.\n * @returns A promise resolving to the decrypted data as a Uint8Array.\n */\nexport async function decryptToBuffer(\n  inputPath: string,\n  passphrase: string,\n  keyfilePath?: string,\n): Promise<Uint8Array> {\n  const [fd, tempPath] = GLib.file_open_tmp(\"gtkrypt-XXXXXX\");\n  GLib.close(fd);\n\n  try {\n    await decrypt(inputPath, tempPath, passphrase, { useStoredFilename: false }, undefined, undefined, keyfilePath);\n\n    const tempFile = Gio.File.new_for_path(tempPath);\n    const [, contents] = tempFile.load_contents(null);\n    return contents;\n  } finally {\n    try {\n      Gio.File.new_for_path(tempPath).delete(null);\n    } catch {\n      // Temp file may already be gone.\n    }\n  }\n}\n", "/**\n * Safe logger for gtkrypt.\n *\n * Outputs timestamped, level-prefixed messages to stderr.\n * The API intentionally accepts only a pre-formatted message string\n * to prevent accidental logging of passphrases, keys, or plaintext.\n *\n * Verbosity is controlled by the GTKRYPT_LOG_LEVEL environment variable\n * (values: debug, info, warn, error). Defaults to \"info\".\n */\n\nimport GLib from \"gi://GLib\";\n\n/** Supported log levels ordered by increasing severity. */\nexport type LogLevel = \"debug\" | \"info\" | \"warn\" | \"error\";\n\n/** Numeric severity for each log level (higher = more severe). */\nconst LEVEL_SEVERITY: Readonly<Record<LogLevel, number>> = {\n  debug: 0,\n  info: 1,\n  warn: 2,\n  error: 3,\n};\n\n/** All valid log level strings for validation. */\nconst VALID_LEVELS = new Set<string>([\"debug\", \"info\", \"warn\", \"error\"]);\n\n/**\n * Determine the minimum log level from the environment.\n *\n * Reads GTKRYPT_LOG_LEVEL once and caches the result. Falls back\n * to \"info\" if the variable is unset or contains an invalid value.\n */\nfunction resolveMinLevel(): LogLevel {\n  const envValue = GLib.getenv(\"GTKRYPT_LOG_LEVEL\");\n  if (envValue !== null) {\n    const normalized = envValue.toLowerCase().trim();\n    if (VALID_LEVELS.has(normalized)) {\n      return normalized as LogLevel;\n    }\n  }\n  return \"info\";\n}\n\nlet cachedMinLevel: LogLevel | null = null;\n\nfunction getMinLevel(): LogLevel {\n  if (cachedMinLevel === null) {\n    cachedMinLevel = resolveMinLevel();\n  }\n  return cachedMinLevel;\n}\n\n/**\n * Format an ISO-8601 timestamp for the current moment.\n */\nfunction timestamp(): string {\n  const now = GLib.DateTime.new_now_local();\n  if (now === null) {\n    return new Date().toISOString();\n  }\n  return now.format(\"%Y-%m-%dT%H:%M:%S\") ?? new Date().toISOString();\n}\n\n/**\n * Log a message to stderr with a timestamp and level prefix.\n *\n * Messages below the configured minimum level are silently dropped.\n * This function intentionally accepts only a single message string\n * -- never pass sensitive data such as passphrases, keys, or file\n * contents as the message.\n *\n * @param level - Severity of the message.\n * @param message - Human-readable log message (must not contain secrets).\n */\nexport function log(level: LogLevel, message: string): void {\n  const minLevel = getMinLevel();\n  if (LEVEL_SEVERITY[level] < LEVEL_SEVERITY[minLevel]) {\n    return;\n  }\n\n  const prefix = level.toUpperCase().padEnd(5);\n  const line = `[${timestamp()}] ${prefix} ${message}`;\n  printerr(line);\n}\n", "/**\n * Unit tests for manifest creation, serialization, and deserialization.\n */\n\nimport { assert, assertEqual, assertThrows, report } from \"../harness.js\";\nimport {\n  createEmptyManifest,\n  serializeManifest,\n  deserializeManifest,\n} from \"../../src/services/manifest.js\";\nimport type { VaultManifest, VaultItem } from \"../../src/models/types.js\";\n\n// ---------------------------------------------------------------------------\n// createEmptyManifest\n// ---------------------------------------------------------------------------\n\nconst manifest = createEmptyManifest(\"Test Vault\", \"balanced\");\n\nassertEqual(manifest.version, 1, \"createEmptyManifest returns version 1\");\nassertEqual(manifest.name, \"Test Vault\", \"createEmptyManifest has correct name\");\nassertEqual(manifest.kdfPreset, \"balanced\", \"createEmptyManifest has correct kdfPreset\");\nassertEqual(manifest.items.length, 0, \"createEmptyManifest has empty items array\");\nassertEqual(manifest.categories.length, 10, \"createEmptyManifest has 10 default categories\");\n\n// Settings defaults\nassertEqual(manifest.settings.autoLockMinutes, 5, \"Default autoLockMinutes is 5\");\nassertEqual(manifest.settings.defaultCategory, \"other\", \"Default category is 'other'\");\nassertEqual(manifest.settings.sortOrder, \"date\", \"Default sortOrder is 'date'\");\nassertEqual(manifest.settings.viewMode, \"list\", \"Default viewMode is 'list'\");\n\n// ---------------------------------------------------------------------------\n// Roundtrip: create -> serialize -> deserialize\n// ---------------------------------------------------------------------------\n\nconst bytes = serializeManifest(manifest);\nconst restored = deserializeManifest(bytes);\n\nassertEqual(restored.version, manifest.version, \"Roundtrip preserves version\");\nassertEqual(restored.name, manifest.name, \"Roundtrip preserves name\");\nassertEqual(restored.kdfPreset, manifest.kdfPreset, \"Roundtrip preserves kdfPreset\");\nassertEqual(restored.items.length, 0, \"Roundtrip preserves empty items array\");\n\n// Roundtrip with an item\nconst testItem: VaultItem = {\n  id: \"test-uuid-001\",\n  type: \"record\",\n  name: \"Test Record\",\n  category: \"banking\",\n  tags: [\"test\", \"unit\"],\n  createdAt: \"2025-01-01T00:00:00.000Z\",\n  modifiedAt: \"2025-01-02T00:00:00.000Z\",\n  accessedAt: \"2025-01-03T00:00:00.000Z\",\n  favorite: true,\n  fields: { bankName: \"Test Bank\", accountNumber: \"99999\" },\n};\n\nconst manifestWithItem: VaultManifest = {\n  ...manifest,\n  items: [testItem],\n};\n\nconst bytes2 = serializeManifest(manifestWithItem);\nconst restored2 = deserializeManifest(bytes2);\n\nassertEqual(restored2.items.length, 1, \"Roundtrip preserves items count\");\nassertEqual(restored2.items[0].name, \"Test Record\", \"Roundtrip preserves item name\");\nassertEqual(restored2.items[0].favorite, true, \"Roundtrip preserves item favorite\");\n\n// Roundtrip preserves settings\nassertEqual(\n  restored.settings.autoLockMinutes,\n  manifest.settings.autoLockMinutes,\n  \"Roundtrip preserves autoLockMinutes\",\n);\nassertEqual(\n  restored.settings.defaultCategory,\n  manifest.settings.defaultCategory,\n  \"Roundtrip preserves defaultCategory\",\n);\nassertEqual(\n  restored.settings.sortOrder,\n  manifest.settings.sortOrder,\n  \"Roundtrip preserves sortOrder\",\n);\nassertEqual(\n  restored.settings.viewMode,\n  manifest.settings.viewMode,\n  \"Roundtrip preserves viewMode\",\n);\n\n// ---------------------------------------------------------------------------\n// deserializeManifest error cases\n// ---------------------------------------------------------------------------\n\n// Wrong version\nconst badVersion = { ...manifest, version: 99 };\nconst badVersionBytes = new TextEncoder().encode(JSON.stringify(badVersion));\nassertThrows(\n  () => deserializeManifest(badVersionBytes),\n  \"VaultCorruptError\",\n  \"Rejects manifest with version !== 1\",\n);\n\n// Invalid JSON\nconst invalidJsonBytes = new TextEncoder().encode(\"not valid json {{{\");\nassertThrows(\n  () => deserializeManifest(invalidJsonBytes),\n  \"VaultCorruptError\",\n  \"Rejects invalid JSON\",\n);\n\n// Empty bytes\nconst emptyBytes = new Uint8Array(0);\nassertThrows(\n  () => deserializeManifest(emptyBytes),\n  \"VaultCorruptError\",\n  \"Rejects empty bytes\",\n);\n\n// ---------------------------------------------------------------------------\n// serializeManifest produces valid JSON\n// ---------------------------------------------------------------------------\n\nconst serialized = serializeManifest(manifest);\nconst jsonText = new TextDecoder().decode(serialized);\nlet parsed: unknown = null;\ntry {\n  parsed = JSON.parse(jsonText);\n} catch {\n  // parsed stays null\n}\nassert(parsed !== null, \"serializeManifest produces valid parseable JSON\");\n\n// ---------------------------------------------------------------------------\nreport(\"manifest\");\n"],
  "mappings": "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",
  "names": ["GLib", "Gio", "GLib", "GLib", "manifest", "bytes"]
}

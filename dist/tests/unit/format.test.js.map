{
  "version": 3,
  "sources": ["../../../tests/harness.ts", "../../../src/util/i18n.ts", "../../../src/models/errors.ts", "../../../src/util/bytes.ts", "../../../src/services/format.ts", "../../../tests/unit/format.test.ts"],
  "sourcesContent": ["/**\n * Minimal GJS test harness with assertion helpers.\n *\n * Each test file imports from this module, runs assertions, and\n * calls `report()` at the end. Non-zero exit on any failure.\n */\n\nlet _passed = 0;\nlet _failed = 0;\nconst _errors: string[] = [];\n\nexport function assert(condition: boolean, message: string): void {\n  if (condition) {\n    _passed++;\n  } else {\n    _failed++;\n    _errors.push(`  FAIL: ${message}`);\n  }\n}\n\nexport function assertEqual<T>(actual: T, expected: T, message: string): void {\n  if (actual === expected) {\n    _passed++;\n  } else {\n    _failed++;\n    _errors.push(`  FAIL: ${message}\\n    expected: ${String(expected)}\\n    actual:   ${String(actual)}`);\n  }\n}\n\nexport function assertDeepEqual(actual: Uint8Array, expected: Uint8Array, message: string): void {\n  if (actual.length !== expected.length) {\n    _failed++;\n    _errors.push(`  FAIL: ${message}\\n    length mismatch: expected ${expected.length}, got ${actual.length}`);\n    return;\n  }\n  for (let i = 0; i < actual.length; i++) {\n    if (actual[i] !== expected[i]) {\n      _failed++;\n      _errors.push(`  FAIL: ${message}\\n    byte ${i} differs: expected ${expected[i]}, got ${actual[i]}`);\n      return;\n    }\n  }\n  _passed++;\n}\n\nexport function assertThrows(fn: () => void, errorName: string, message: string): void {\n  try {\n    fn();\n    _failed++;\n    _errors.push(`  FAIL: ${message}\\n    expected ${errorName} to be thrown, but nothing was thrown`);\n  } catch (e: unknown) {\n    const err = e as { name?: string };\n    if (err.name === errorName) {\n      _passed++;\n    } else {\n      _failed++;\n      _errors.push(`  FAIL: ${message}\\n    expected ${errorName}, got ${err.name ?? String(e)}`);\n    }\n  }\n}\n\nexport function assertBigIntEqual(actual: bigint, expected: bigint, message: string): void {\n  if (actual === expected) {\n    _passed++;\n  } else {\n    _failed++;\n    _errors.push(`  FAIL: ${message}\\n    expected: ${String(expected)}\\n    actual:   ${String(actual)}`);\n  }\n}\n\nexport function report(suiteName: string): void {\n  if (_errors.length > 0) {\n    printerr(`\\n${suiteName}:`);\n    for (const err of _errors) {\n      printerr(err);\n    }\n  }\n  print(`${suiteName}: ${_passed} passed, ${_failed} failed`);\n  if (_failed > 0) {\n    imports.system.exit(1);\n  }\n}\n", "import GLib from \"gi://GLib\";\n\nconst domain = \"gtkrypt\";\n\nimports.gettext.bindtextdomain(domain, GLib.get_home_dir());\nimports.gettext.textdomain(domain);\n\nexport const _ = imports.gettext.gettext;\nexport const ngettext = imports.gettext.ngettext;\n", "/**\n * Typed error classes for gtkrypt.\n *\n * Every error that can surface to the user has a `userMessage` property\n * containing a human-readable string suitable for display in the UI.\n * The `name` property is set to the class name for reliable `instanceof`\n * checks and clear stack traces.\n */\n\nimport { _ } from \"../util/i18n.js\";\n\n/** Base error class for all gtkrypt errors. */\nexport class GtkryptError extends Error {\n  public readonly userMessage: string;\n\n  constructor(message: string, userMessage: string) {\n    super(message);\n    this.name = \"GtkryptError\";\n    this.userMessage = userMessage;\n  }\n}\n\n/** The passphrase did not match or the file integrity check failed. */\nexport class WrongPassphraseError extends GtkryptError {\n  constructor(message = \"Wrong passphrase or integrity check failed\") {\n    super(message, _(\"Incorrect passphrase or file corrupted.\"));\n    this.name = \"WrongPassphraseError\";\n  }\n}\n\n/** The file is not a valid `.gtkrypt` container or has been corrupted. */\nexport class CorruptFileError extends GtkryptError {\n  constructor(message = \"Corrupt or unrecognized file format\") {\n    super(message, _(\"Not a gtkrypt file or file is corrupted.\"));\n    this.name = \"CorruptFileError\";\n  }\n}\n\n/** The container version is newer than this build understands. */\nexport class UnsupportedVersionError extends GtkryptError {\n  constructor(message = \"Unsupported container version\") {\n    super(message, _(\"This file was created with a newer version of gtkrypt.\"));\n    this.name = \"UnsupportedVersionError\";\n  }\n}\n\n/** The application lacks write permission to the target directory. */\nexport class PermissionError extends GtkryptError {\n  constructor(message = \"Permission denied\") {\n    super(message, _(\"No permission to write to the target directory.\"));\n    this.name = \"PermissionError\";\n  }\n}\n\n/** The user cancelled the operation. This is a silent error. */\nexport class CancelledError extends GtkryptError {\n  constructor(message = \"Operation cancelled\") {\n    super(message, \"\");\n    this.name = \"CancelledError\";\n  }\n}\n\n/** An unexpected internal error in the crypto backend. */\nexport class InternalCryptoError extends GtkryptError {\n  constructor(message = \"Internal crypto error\") {\n    super(message, _(\"An internal error occurred. Please report this bug.\"));\n    this.name = \"InternalCryptoError\";\n  }\n}\n\n// ---------------------------------------------------------------------------\n// Vault errors\n// ---------------------------------------------------------------------------\n\n/** Operation attempted while vault is locked. */\nexport class VaultLockedError extends GtkryptError {\n  constructor(message = \"Vault is locked\") {\n    super(message, _(\"The vault is locked. Please unlock it first.\"));\n    this.name = \"VaultLockedError\";\n  }\n}\n\n/** Vault directory does not exist. */\nexport class VaultNotFoundError extends GtkryptError {\n  constructor(message = \"Vault not found\") {\n    super(message, _(\"Vault not found.\"));\n    this.name = \"VaultNotFoundError\";\n  }\n}\n\n/** Manifest failed to parse after decryption. */\nexport class VaultCorruptError extends GtkryptError {\n  constructor(message = \"Vault data is corrupted\", userMessage?: string) {\n    super(message, userMessage ?? _(\"The vault data is corrupted.\"));\n    this.name = \"VaultCorruptError\";\n  }\n}\n\n/** An item's encrypted file is missing from the vault directory. */\nexport class ItemFileMissingError extends GtkryptError {\n  constructor(message = \"Item file is missing from vault\") {\n    super(\n      message,\n      _(\"Item file is missing from vault. The item may be corrupted.\"),\n    );\n    this.name = \"ItemFileMissingError\";\n  }\n}\n\n/** The manifest was modified externally since last load/save. */\nexport class ManifestConcurrentModificationError extends GtkryptError {\n  constructor(message = \"Manifest was modified externally\") {\n    super(\n      message,\n      _(\"The vault was modified externally. Please lock and re-unlock to reload.\"),\n    );\n    this.name = \"ManifestConcurrentModificationError\";\n  }\n}\n\n/** Item UUID not found in manifest. */\nexport class ItemNotFoundError extends GtkryptError {\n  constructor(message = \"Item not found in vault\") {\n    super(message, _(\"Item not found in vault.\"));\n    this.name = \"ItemNotFoundError\";\n  }\n}\n\n/** Vault with same name already exists. */\nexport class DuplicateVaultError extends GtkryptError {\n  constructor(message = \"A vault with this name already exists\") {\n    super(message, _(\"A vault with this name already exists.\"));\n    this.name = \"DuplicateVaultError\";\n  }\n}\n", "/**\n * Binary read/write helpers for working with Uint8Array buffers.\n *\n * All multi-byte operations use big-endian byte order to match\n * the gtkrypt container format specification. Implementations use\n * DataView for correctness and portability (no Node.js Buffer).\n */\n\n/**\n * Write a single unsigned byte at the given offset.\n */\nexport function writeUint8(\n  buffer: Uint8Array,\n  offset: number,\n  value: number,\n): void {\n  buffer[offset] = value & 0xff;\n}\n\n/**\n * Write an unsigned 16-bit integer in big-endian byte order.\n */\nexport function writeUint16BE(\n  buffer: Uint8Array,\n  offset: number,\n  value: number,\n): void {\n  const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);\n  view.setUint16(offset, value, false);\n}\n\n/**\n * Write an unsigned 32-bit integer in big-endian byte order.\n */\nexport function writeUint32BE(\n  buffer: Uint8Array,\n  offset: number,\n  value: number,\n): void {\n  const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);\n  view.setUint32(offset, value, false);\n}\n\n/**\n * Write an unsigned 64-bit integer in big-endian byte order.\n *\n * Accepts a `bigint` because JavaScript numbers cannot represent\n * the full uint64 range without loss of precision.\n */\nexport function writeUint64BE(\n  buffer: Uint8Array,\n  offset: number,\n  value: bigint,\n): void {\n  const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);\n  view.setBigUint64(offset, value, false);\n}\n\n/**\n * Read a single unsigned byte from the given offset.\n */\nexport function readUint8(buffer: Uint8Array, offset: number): number {\n  return buffer[offset];\n}\n\n/**\n * Read an unsigned 16-bit integer in big-endian byte order.\n */\nexport function readUint16BE(buffer: Uint8Array, offset: number): number {\n  const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);\n  return view.getUint16(offset, false);\n}\n\n/**\n * Read an unsigned 32-bit integer in big-endian byte order.\n */\nexport function readUint32BE(buffer: Uint8Array, offset: number): number {\n  const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);\n  return view.getUint32(offset, false);\n}\n\n/**\n * Read an unsigned 64-bit integer in big-endian byte order.\n *\n * Returns a `bigint` because JavaScript numbers cannot represent\n * the full uint64 range without loss of precision.\n */\nexport function readUint64BE(buffer: Uint8Array, offset: number): bigint {\n  const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);\n  return view.getBigUint64(offset, false);\n}\n\n/**\n * Concatenate multiple Uint8Array instances into a single Uint8Array.\n *\n * Returns an empty Uint8Array if called with no arguments.\n */\nexport function concatBytes(...arrays: Uint8Array[]): Uint8Array {\n  let totalLength = 0;\n  for (const arr of arrays) {\n    totalLength += arr.byteLength;\n  }\n\n  const result = new Uint8Array(totalLength);\n  let offset = 0;\n  for (const arr of arrays) {\n    result.set(arr, offset);\n    offset += arr.byteLength;\n  }\n\n  return result;\n}\n", "/**\n * Container format parser for `.gtkrypt` files (read-only).\n *\n * This module decodes the binary header written by the Rust crypto\n * backend. It is intentionally read-only -- encoding is performed\n * exclusively by the Rust binary to keep the single source of truth\n * for header construction in one place.\n *\n * The byte layout is documented in SCOPE.md under \"Container format\".\n */\n\nimport type { ContainerHeader, KdfParams } from \"../models/types.js\";\nimport {\n  CorruptFileError,\n  UnsupportedVersionError,\n} from \"../models/errors.js\";\nimport {\n  readUint8,\n  readUint16BE,\n  readUint32BE,\n  readUint64BE,\n} from \"../util/bytes.js\";\n\n/** Magic bytes at the start of every `.gtkrypt` file: \"GTKRYPT\\0\". */\nexport const HEADER_MAGIC = new Uint8Array([\n  0x47, 0x54, 0x4b, 0x52, 0x59, 0x50, 0x54, 0x00,\n]);\n\n/** The newest container version this build can read. */\nexport const CURRENT_VERSION = 2;\n\n/** KDF identifier for Argon2id. */\nconst KDF_ARGON2ID = 1;\n\n/** Expected salt length in bytes. */\nconst SALT_LENGTH = 16;\n\n/** Expected nonce/IV length in bytes. */\nconst NONCE_LENGTH = 12;\n\n/** Minimum header sizes (no stored filename). */\nconst MIN_HEADER_SIZE_V1 = 67;\nconst MIN_HEADER_SIZE_V2 = 71;\n\n/**\n * Parse a `.gtkrypt` container header from raw bytes.\n *\n * The caller should pass at least the first `MIN_HEADER_SIZE` bytes of\n * the file (more if a stored filename is present). This function does\n * not read or validate any ciphertext -- only the header fields.\n *\n * @param bytes - Raw bytes from the beginning of a `.gtkrypt` file.\n * @returns The parsed {@link ContainerHeader}.\n * @throws {@link CorruptFileError} if the magic bytes are wrong, the\n *   KDF identifier is unrecognised, or the buffer is too short.\n * @throws {@link UnsupportedVersionError} if the version field does\n *   not match {@link CURRENT_VERSION}.\n */\nexport function parseHeader(bytes: Uint8Array): ContainerHeader {\n  if (bytes.byteLength < MIN_HEADER_SIZE_V1) {\n    throw new CorruptFileError(\"Header too short to be a valid gtkrypt file\");\n  }\n\n  // -- Magic (offset 0, 8 bytes) --\n  for (let i = 0; i < HEADER_MAGIC.length; i++) {\n    if (bytes[i] !== HEADER_MAGIC[i]) {\n      throw new CorruptFileError(\"Invalid magic bytes\");\n    }\n  }\n\n  // -- Version (offset 8, 1 byte) --\n  const version = readUint8(bytes, 8);\n  if (version !== 1 && version !== 2) {\n    throw new UnsupportedVersionError(\n      `Container version ${version} is not supported (expected 1 or ${CURRENT_VERSION})`,\n    );\n  }\n  if (version === 2 && bytes.byteLength < MIN_HEADER_SIZE_V2) {\n    throw new CorruptFileError(\"Header too short to be a valid gtkrypt v2 file\");\n  }\n\n  // -- KDF ID (offset 9, 1 byte) --\n  const kdfId = readUint8(bytes, 9);\n  if (kdfId !== KDF_ARGON2ID) {\n    throw new CorruptFileError(`Unknown KDF identifier: ${kdfId}`);\n  }\n\n  // -- KDF parameters --\n  const timeCost = readUint32BE(bytes, 10);\n  const memoryCost = readUint32BE(bytes, 14);\n  const parallelism = readUint8(bytes, 18);\n\n  const kdfParams: KdfParams = { timeCost, memoryCost, parallelism };\n\n  // -- Salt (offset 19: length, offset 20: data) --\n  const saltLength = readUint8(bytes, 19);\n  if (saltLength !== SALT_LENGTH) {\n    throw new CorruptFileError(\n      `Unexpected salt length: ${saltLength} (expected ${SALT_LENGTH})`,\n    );\n  }\n  const salt = bytes.slice(20, 20 + saltLength);\n\n  // -- Nonce (offset 36: length, offset 37: data) --\n  const nonceLength = readUint8(bytes, 36);\n  if (nonceLength !== NONCE_LENGTH) {\n    throw new CorruptFileError(\n      `Unexpected nonce length: ${nonceLength} (expected ${NONCE_LENGTH})`,\n    );\n  }\n  const nonce = bytes.slice(37, 37 + nonceLength);\n\n  // -- Filename (offset 49: uint16BE length, offset 51: UTF-8 data) --\n  const filenameLength = readUint16BE(bytes, 49);\n\n  const requiredSize =\n    (version === 2 ? MIN_HEADER_SIZE_V2 : MIN_HEADER_SIZE_V1) + filenameLength;\n  if (bytes.byteLength < requiredSize) {\n    throw new CorruptFileError(\n      \"Header too short: filename extends past available bytes\",\n    );\n  }\n\n  let filename = \"\";\n  if (filenameLength > 0) {\n    const decoder = new TextDecoder(\"utf-8\");\n    filename = decoder.decode(bytes.slice(51, 51 + filenameLength));\n  }\n\n  const offset = 51 + filenameLength;\n\n  let mode: number | undefined;\n  let fileSize: bigint;\n  let ciphertextLength: bigint;\n\n  if (version === 2) {\n    // -- Mode (uint32BE at 51 + filenameLength) --\n    mode = readUint32BE(bytes, offset);\n\n    // -- File size (uint64BE at 55 + filenameLength) --\n    fileSize = readUint64BE(bytes, offset + 4);\n\n    // -- Ciphertext length (uint64BE at 63 + filenameLength) --\n    ciphertextLength = readUint64BE(bytes, offset + 12);\n  } else {\n    // -- File size (uint64BE at 51 + filenameLength) --\n    fileSize = readUint64BE(bytes, offset);\n\n    // -- Ciphertext length (uint64BE at 59 + filenameLength) --\n    ciphertextLength = readUint64BE(bytes, offset + 8);\n  }\n\n  return {\n    version,\n    kdfId,\n    kdfParams,\n    salt,\n    nonce,\n    filename,\n    mode,\n    fileSize,\n    ciphertextLength,\n  };\n}\n\n/**\n * Extract the Additional Authenticated Data (AAD) bytes from a header.\n *\n * AAD covers bytes 0 through 48 (inclusive) -- everything from the\n * magic through the end of the nonce. This range is authenticated\n * by GCM to detect header tampering.\n *\n * @param bytes - Raw bytes from the beginning of a `.gtkrypt` file.\n *   Must be at least 49 bytes long.\n * @returns A new Uint8Array containing the AAD region.\n * @throws {@link CorruptFileError} if the buffer is shorter than 49 bytes.\n */\nexport function getAADBytes(bytes: Uint8Array): Uint8Array {\n  const AAD_END = 49;\n  if (bytes.byteLength < AAD_END) {\n    throw new CorruptFileError(\"Buffer too short to extract AAD bytes\");\n  }\n  return bytes.slice(0, AAD_END);\n}\n", "/**\n * Unit tests for the container format parser (src/services/format.ts).\n *\n * Tests cover v1 and v2 header parsing, error cases for invalid\n * magic bytes, unsupported versions, short buffers, and edge cases\n * like zero-length filenames. Also tests getAADBytes extraction.\n */\n\nimport {\n  assert,\n  assertEqual,\n  assertDeepEqual,\n  assertBigIntEqual,\n  assertThrows,\n  report,\n} from \"../../tests/harness.js\";\nimport {\n  parseHeader,\n  HEADER_MAGIC,\n  CURRENT_VERSION,\n  getAADBytes,\n} from \"../../src/services/format.js\";\nimport {\n  writeUint8,\n  writeUint16BE,\n  writeUint32BE,\n  writeUint64BE,\n} from \"../../src/util/bytes.js\";\n\n// ---------------------------------------------------------------------------\n// Helper: build a valid header buffer from field values\n// ---------------------------------------------------------------------------\n\ninterface HeaderFields {\n  version: number;\n  kdfId: number;\n  timeCost: number;\n  memoryCost: number;\n  parallelism: number;\n  salt: Uint8Array;\n  nonce: Uint8Array;\n  filename: string;\n  mode?: number;\n  fileSize: bigint;\n  ciphertextLength: bigint;\n}\n\nfunction buildHeader(fields: HeaderFields): Uint8Array {\n  const encoder = new TextEncoder();\n  const filenameBytes = encoder.encode(fields.filename);\n  const filenameLength = filenameBytes.byteLength;\n\n  const isV2 = fields.version === 2;\n  const totalSize = (isV2 ? 71 : 67) + filenameLength;\n  const buf = new Uint8Array(totalSize);\n\n  // Magic (offset 0, 8 bytes)\n  buf.set(HEADER_MAGIC, 0);\n\n  // Version (offset 8, 1 byte)\n  writeUint8(buf, 8, fields.version);\n\n  // KDF ID (offset 9, 1 byte)\n  writeUint8(buf, 9, fields.kdfId);\n\n  // KDF params\n  writeUint32BE(buf, 10, fields.timeCost);\n  writeUint32BE(buf, 14, fields.memoryCost);\n  writeUint8(buf, 18, fields.parallelism);\n\n  // Salt (offset 19: length, offset 20: data)\n  writeUint8(buf, 19, fields.salt.byteLength);\n  buf.set(fields.salt, 20);\n\n  // Nonce (offset 36: length, offset 37: data)\n  writeUint8(buf, 36, fields.nonce.byteLength);\n  buf.set(fields.nonce, 37);\n\n  // Filename length (offset 49, uint16 BE)\n  writeUint16BE(buf, 49, filenameLength);\n\n  // Filename data (offset 51)\n  if (filenameLength > 0) {\n    buf.set(filenameBytes, 51);\n  }\n\n  const offset = 51 + filenameLength;\n\n  if (isV2) {\n    // Mode (offset 51+N, uint32 BE)\n    writeUint32BE(buf, offset, fields.mode ?? 0);\n    // File size (offset 55+N, uint64 BE)\n    writeUint64BE(buf, offset + 4, fields.fileSize);\n    // Ciphertext length (offset 63+N, uint64 BE)\n    writeUint64BE(buf, offset + 12, fields.ciphertextLength);\n  } else {\n    // File size (offset 51+N, uint64 BE)\n    writeUint64BE(buf, offset, fields.fileSize);\n    // Ciphertext length (offset 59+N, uint64 BE)\n    writeUint64BE(buf, offset + 8, fields.ciphertextLength);\n  }\n\n  return buf;\n}\n\n// ---------------------------------------------------------------------------\n// Shared test fixtures\n// ---------------------------------------------------------------------------\n\nconst TEST_SALT = new Uint8Array([\n  0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,\n  0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10,\n]);\n\nconst TEST_NONCE = new Uint8Array([\n  0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6,\n  0xa7, 0xa8, 0xa9, 0xaa, 0xab, 0xac,\n]);\n\n// ---------------------------------------------------------------------------\n// Test 1: Valid v2 header with filename\n// ---------------------------------------------------------------------------\n\n{\n  const fields: HeaderFields = {\n    version: 2,\n    kdfId: 1,\n    timeCost: 3,\n    memoryCost: 65536,\n    parallelism: 4,\n    salt: TEST_SALT,\n    nonce: TEST_NONCE,\n    filename: \"secret.txt\",\n    mode: 0o644,\n    fileSize: 1024n,\n    ciphertextLength: 1040n,\n  };\n\n  const buf = buildHeader(fields);\n  const header = parseHeader(buf);\n\n  assertEqual(header.version, 2, \"v2: version\");\n  assertEqual(header.kdfId, 1, \"v2: kdfId\");\n  assertEqual(header.kdfParams.timeCost, 3, \"v2: timeCost\");\n  assertEqual(header.kdfParams.memoryCost, 65536, \"v2: memoryCost\");\n  assertEqual(header.kdfParams.parallelism, 4, \"v2: parallelism\");\n  assertDeepEqual(header.salt, TEST_SALT, \"v2: salt\");\n  assertDeepEqual(header.nonce, TEST_NONCE, \"v2: nonce\");\n  assertEqual(header.filename, \"secret.txt\", \"v2: filename\");\n  assertEqual(header.mode, 0o644, \"v2: mode\");\n  assertBigIntEqual(header.fileSize, 1024n, \"v2: fileSize\");\n  assertBigIntEqual(header.ciphertextLength, 1040n, \"v2: ciphertextLength\");\n}\n\n// ---------------------------------------------------------------------------\n// Test 2: Valid v1 header (no mode field)\n// ---------------------------------------------------------------------------\n\n{\n  const fields: HeaderFields = {\n    version: 1,\n    kdfId: 1,\n    timeCost: 4,\n    memoryCost: 262144,\n    parallelism: 2,\n    salt: TEST_SALT,\n    nonce: TEST_NONCE,\n    filename: \"report.pdf\",\n    fileSize: 999999n,\n    ciphertextLength: 1000015n,\n  };\n\n  const buf = buildHeader(fields);\n  const header = parseHeader(buf);\n\n  assertEqual(header.version, 1, \"v1: version\");\n  assertEqual(header.kdfId, 1, \"v1: kdfId\");\n  assertEqual(header.kdfParams.timeCost, 4, \"v1: timeCost\");\n  assertEqual(header.kdfParams.memoryCost, 262144, \"v1: memoryCost\");\n  assertEqual(header.kdfParams.parallelism, 2, \"v1: parallelism\");\n  assertDeepEqual(header.salt, TEST_SALT, \"v1: salt\");\n  assertDeepEqual(header.nonce, TEST_NONCE, \"v1: nonce\");\n  assertEqual(header.filename, \"report.pdf\", \"v1: filename\");\n  assertEqual(header.mode, undefined, \"v1: mode is undefined\");\n  assertBigIntEqual(header.fileSize, 999999n, \"v1: fileSize\");\n  assertBigIntEqual(header.ciphertextLength, 1000015n, \"v1: ciphertextLength\");\n}\n\n// ---------------------------------------------------------------------------\n// Test 3: Reject invalid magic bytes\n// ---------------------------------------------------------------------------\n\n{\n  const fields: HeaderFields = {\n    version: 2,\n    kdfId: 1,\n    timeCost: 3,\n    memoryCost: 65536,\n    parallelism: 4,\n    salt: TEST_SALT,\n    nonce: TEST_NONCE,\n    filename: \"\",\n    mode: 0,\n    fileSize: 0n,\n    ciphertextLength: 0n,\n  };\n\n  const buf = buildHeader(fields);\n\n  // Corrupt the first magic byte\n  buf[0] = 0x00;\n\n  assertThrows(\n    () => parseHeader(buf),\n    \"CorruptFileError\",\n    \"invalid magic: corrupted first byte\",\n  );\n\n  // Restore first byte, corrupt last magic byte\n  buf[0] = 0x47;\n  buf[7] = 0xff;\n\n  assertThrows(\n    () => parseHeader(buf),\n    \"CorruptFileError\",\n    \"invalid magic: corrupted last byte\",\n  );\n}\n\n// ---------------------------------------------------------------------------\n// Test 4: Reject unsupported version\n// ---------------------------------------------------------------------------\n\n{\n  const fields: HeaderFields = {\n    version: 2,\n    kdfId: 1,\n    timeCost: 3,\n    memoryCost: 65536,\n    parallelism: 4,\n    salt: TEST_SALT,\n    nonce: TEST_NONCE,\n    filename: \"\",\n    mode: 0,\n    fileSize: 0n,\n    ciphertextLength: 0n,\n  };\n\n  const buf = buildHeader(fields);\n\n  // Overwrite version to 99\n  writeUint8(buf, 8, 99);\n\n  assertThrows(\n    () => parseHeader(buf),\n    \"UnsupportedVersionError\",\n    \"unsupported version 99\",\n  );\n\n  // Also test version 0\n  writeUint8(buf, 8, 0);\n\n  assertThrows(\n    () => parseHeader(buf),\n    \"UnsupportedVersionError\",\n    \"unsupported version 0\",\n  );\n}\n\n// ---------------------------------------------------------------------------\n// Test 5: Zero-length filename\n// ---------------------------------------------------------------------------\n\n{\n  const fields: HeaderFields = {\n    version: 2,\n    kdfId: 1,\n    timeCost: 3,\n    memoryCost: 65536,\n    parallelism: 4,\n    salt: TEST_SALT,\n    nonce: TEST_NONCE,\n    filename: \"\",\n    mode: 0o755,\n    fileSize: 512n,\n    ciphertextLength: 528n,\n  };\n\n  const buf = buildHeader(fields);\n  const header = parseHeader(buf);\n\n  assertEqual(header.filename, \"\", \"empty filename: value is empty string\");\n  assertEqual(header.mode, 0o755, \"empty filename: mode still parsed\");\n  assertBigIntEqual(header.fileSize, 512n, \"empty filename: fileSize\");\n  assertBigIntEqual(header.ciphertextLength, 528n, \"empty filename: ciphertextLength\");\n}\n\n// ---------------------------------------------------------------------------\n// Test 6: Non-zero filename decoded correctly from UTF-8\n// ---------------------------------------------------------------------------\n\n{\n  // Test with ASCII filename\n  const asciiFields: HeaderFields = {\n    version: 2,\n    kdfId: 1,\n    timeCost: 3,\n    memoryCost: 65536,\n    parallelism: 4,\n    salt: TEST_SALT,\n    nonce: TEST_NONCE,\n    filename: \"hello-world_2024.tar.gz\",\n    mode: 0o644,\n    fileSize: 2048n,\n    ciphertextLength: 2064n,\n  };\n\n  const asciiHeader = parseHeader(buildHeader(asciiFields));\n  assertEqual(asciiHeader.filename, \"hello-world_2024.tar.gz\", \"ASCII filename decoded\");\n\n  // Test with multi-byte UTF-8 filename\n  const unicodeFields: HeaderFields = {\n    version: 2,\n    kdfId: 1,\n    timeCost: 3,\n    memoryCost: 65536,\n    parallelism: 4,\n    salt: TEST_SALT,\n    nonce: TEST_NONCE,\n    filename: \"\\u00e4\\u00f6\\u00fc\\u00df-\\u6587\\u4ef6.txt\",\n    mode: 0o600,\n    fileSize: 256n,\n    ciphertextLength: 272n,\n  };\n\n  const unicodeHeader = parseHeader(buildHeader(unicodeFields));\n  assertEqual(\n    unicodeHeader.filename,\n    \"\\u00e4\\u00f6\\u00fc\\u00df-\\u6587\\u4ef6.txt\",\n    \"UTF-8 multi-byte filename decoded\",\n  );\n}\n\n// ---------------------------------------------------------------------------\n// Test 7: Buffer too short\n// ---------------------------------------------------------------------------\n\n{\n  // Completely empty buffer\n  assertThrows(\n    () => parseHeader(new Uint8Array(0)),\n    \"CorruptFileError\",\n    \"buffer too short: empty buffer\",\n  );\n\n  // One byte short of minimum v1 header (67 bytes)\n  assertThrows(\n    () => parseHeader(new Uint8Array(66)),\n    \"CorruptFileError\",\n    \"buffer too short: 66 bytes (need 67 for v1)\",\n  );\n\n  // Exactly v1 minimum size but claiming v2 -- should fail\n  // because v2 needs 71 bytes minimum\n  const v2ShortFields: HeaderFields = {\n    version: 1, // build as v1 (67 bytes) ...\n    kdfId: 1,\n    timeCost: 3,\n    memoryCost: 65536,\n    parallelism: 4,\n    salt: TEST_SALT,\n    nonce: TEST_NONCE,\n    filename: \"\",\n    fileSize: 0n,\n    ciphertextLength: 0n,\n  };\n\n  const v2ShortBuf = buildHeader(v2ShortFields);\n  // Now change the version byte to 2 so the parser expects 71 bytes\n  writeUint8(v2ShortBuf, 8, 2);\n\n  assertThrows(\n    () => parseHeader(v2ShortBuf),\n    \"CorruptFileError\",\n    \"buffer too short: 67 bytes claiming v2 (need 71)\",\n  );\n\n  // Buffer has valid header but filename extends past available bytes\n  // Build a v2 header with no filename, then overwrite filenameLength to 10\n  const truncFields: HeaderFields = {\n    version: 2,\n    kdfId: 1,\n    timeCost: 3,\n    memoryCost: 65536,\n    parallelism: 4,\n    salt: TEST_SALT,\n    nonce: TEST_NONCE,\n    filename: \"\",\n    mode: 0,\n    fileSize: 0n,\n    ciphertextLength: 0n,\n  };\n\n  const truncBuf = buildHeader(truncFields);\n  // Overwrite filename length to claim 10 bytes, but buffer has no room\n  writeUint16BE(truncBuf, 49, 10);\n\n  assertThrows(\n    () => parseHeader(truncBuf),\n    \"CorruptFileError\",\n    \"buffer too short: filename extends past available bytes\",\n  );\n}\n\n// ---------------------------------------------------------------------------\n// Test 8: getAADBytes extraction\n// ---------------------------------------------------------------------------\n\n{\n  const fields: HeaderFields = {\n    version: 2,\n    kdfId: 1,\n    timeCost: 3,\n    memoryCost: 65536,\n    parallelism: 4,\n    salt: TEST_SALT,\n    nonce: TEST_NONCE,\n    filename: \"test.bin\",\n    mode: 0o644,\n    fileSize: 100n,\n    ciphertextLength: 116n,\n  };\n\n  const buf = buildHeader(fields);\n  const aad = getAADBytes(buf);\n\n  assertEqual(aad.byteLength, 49, \"AAD: length is 49 bytes\");\n  assertDeepEqual(\n    aad.slice(0, 8),\n    HEADER_MAGIC,\n    \"AAD: starts with magic bytes\",\n  );\n  assertEqual(aad[8], 2, \"AAD: contains version byte\");\n  // AAD ends at byte 48 (inclusive), which is the last nonce byte\n  assertEqual(aad[48], TEST_NONCE[11], \"AAD: last byte is last nonce byte\");\n\n  // getAADBytes should throw on short buffer\n  assertThrows(\n    () => getAADBytes(new Uint8Array(48)),\n    \"CorruptFileError\",\n    \"AAD: buffer too short (48 bytes)\",\n  );\n\n  assertThrows(\n    () => getAADBytes(new Uint8Array(0)),\n    \"CorruptFileError\",\n    \"AAD: buffer too short (0 bytes)\",\n  );\n}\n\n// ---------------------------------------------------------------------------\n// Test 9: CURRENT_VERSION constant\n// ---------------------------------------------------------------------------\n\n{\n  assertEqual(CURRENT_VERSION, 2, \"CURRENT_VERSION is 2\");\n}\n\n// ---------------------------------------------------------------------------\n// Test 10: HEADER_MAGIC matches expected bytes\n// ---------------------------------------------------------------------------\n\n{\n  const expected = new Uint8Array([0x47, 0x54, 0x4b, 0x52, 0x59, 0x50, 0x54, 0x00]);\n  assertDeepEqual(HEADER_MAGIC, expected, \"HEADER_MAGIC is GTKRYPT\\\\0\");\n}\n\n// ---------------------------------------------------------------------------\nreport(\"format\");\n"],
  "mappings": "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",
  "names": []
}

{
  "version": 3,
  "sources": ["../../../tests/harness.ts", "../../../src/util/bytes.ts", "../../../tests/unit/bytes.test.ts"],
  "sourcesContent": ["/**\n * Minimal GJS test harness with assertion helpers.\n *\n * Each test file imports from this module, runs assertions, and\n * calls `report()` at the end. Non-zero exit on any failure.\n */\n\nlet _passed = 0;\nlet _failed = 0;\nconst _errors: string[] = [];\n\nexport function assert(condition: boolean, message: string): void {\n  if (condition) {\n    _passed++;\n  } else {\n    _failed++;\n    _errors.push(`  FAIL: ${message}`);\n  }\n}\n\nexport function assertEqual<T>(actual: T, expected: T, message: string): void {\n  if (actual === expected) {\n    _passed++;\n  } else {\n    _failed++;\n    _errors.push(`  FAIL: ${message}\\n    expected: ${String(expected)}\\n    actual:   ${String(actual)}`);\n  }\n}\n\nexport function assertDeepEqual(actual: Uint8Array, expected: Uint8Array, message: string): void {\n  if (actual.length !== expected.length) {\n    _failed++;\n    _errors.push(`  FAIL: ${message}\\n    length mismatch: expected ${expected.length}, got ${actual.length}`);\n    return;\n  }\n  for (let i = 0; i < actual.length; i++) {\n    if (actual[i] !== expected[i]) {\n      _failed++;\n      _errors.push(`  FAIL: ${message}\\n    byte ${i} differs: expected ${expected[i]}, got ${actual[i]}`);\n      return;\n    }\n  }\n  _passed++;\n}\n\nexport function assertThrows(fn: () => void, errorName: string, message: string): void {\n  try {\n    fn();\n    _failed++;\n    _errors.push(`  FAIL: ${message}\\n    expected ${errorName} to be thrown, but nothing was thrown`);\n  } catch (e: unknown) {\n    const err = e as { name?: string };\n    if (err.name === errorName) {\n      _passed++;\n    } else {\n      _failed++;\n      _errors.push(`  FAIL: ${message}\\n    expected ${errorName}, got ${err.name ?? String(e)}`);\n    }\n  }\n}\n\nexport function assertBigIntEqual(actual: bigint, expected: bigint, message: string): void {\n  if (actual === expected) {\n    _passed++;\n  } else {\n    _failed++;\n    _errors.push(`  FAIL: ${message}\\n    expected: ${String(expected)}\\n    actual:   ${String(actual)}`);\n  }\n}\n\nexport function report(suiteName: string): void {\n  if (_errors.length > 0) {\n    printerr(`\\n${suiteName}:`);\n    for (const err of _errors) {\n      printerr(err);\n    }\n  }\n  print(`${suiteName}: ${_passed} passed, ${_failed} failed`);\n  if (_failed > 0) {\n    imports.system.exit(1);\n  }\n}\n", "/**\n * Binary read/write helpers for working with Uint8Array buffers.\n *\n * All multi-byte operations use big-endian byte order to match\n * the gtkrypt container format specification. Implementations use\n * DataView for correctness and portability (no Node.js Buffer).\n */\n\n/**\n * Write a single unsigned byte at the given offset.\n */\nexport function writeUint8(\n  buffer: Uint8Array,\n  offset: number,\n  value: number,\n): void {\n  buffer[offset] = value & 0xff;\n}\n\n/**\n * Write an unsigned 16-bit integer in big-endian byte order.\n */\nexport function writeUint16BE(\n  buffer: Uint8Array,\n  offset: number,\n  value: number,\n): void {\n  const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);\n  view.setUint16(offset, value, false);\n}\n\n/**\n * Write an unsigned 32-bit integer in big-endian byte order.\n */\nexport function writeUint32BE(\n  buffer: Uint8Array,\n  offset: number,\n  value: number,\n): void {\n  const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);\n  view.setUint32(offset, value, false);\n}\n\n/**\n * Write an unsigned 64-bit integer in big-endian byte order.\n *\n * Accepts a `bigint` because JavaScript numbers cannot represent\n * the full uint64 range without loss of precision.\n */\nexport function writeUint64BE(\n  buffer: Uint8Array,\n  offset: number,\n  value: bigint,\n): void {\n  const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);\n  view.setBigUint64(offset, value, false);\n}\n\n/**\n * Read a single unsigned byte from the given offset.\n */\nexport function readUint8(buffer: Uint8Array, offset: number): number {\n  return buffer[offset];\n}\n\n/**\n * Read an unsigned 16-bit integer in big-endian byte order.\n */\nexport function readUint16BE(buffer: Uint8Array, offset: number): number {\n  const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);\n  return view.getUint16(offset, false);\n}\n\n/**\n * Read an unsigned 32-bit integer in big-endian byte order.\n */\nexport function readUint32BE(buffer: Uint8Array, offset: number): number {\n  const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);\n  return view.getUint32(offset, false);\n}\n\n/**\n * Read an unsigned 64-bit integer in big-endian byte order.\n *\n * Returns a `bigint` because JavaScript numbers cannot represent\n * the full uint64 range without loss of precision.\n */\nexport function readUint64BE(buffer: Uint8Array, offset: number): bigint {\n  const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);\n  return view.getBigUint64(offset, false);\n}\n\n/**\n * Concatenate multiple Uint8Array instances into a single Uint8Array.\n *\n * Returns an empty Uint8Array if called with no arguments.\n */\nexport function concatBytes(...arrays: Uint8Array[]): Uint8Array {\n  let totalLength = 0;\n  for (const arr of arrays) {\n    totalLength += arr.byteLength;\n  }\n\n  const result = new Uint8Array(totalLength);\n  let offset = 0;\n  for (const arr of arrays) {\n    result.set(arr, offset);\n    offset += arr.byteLength;\n  }\n\n  return result;\n}\n", "/**\n * Unit tests for src/util/bytes.ts \u2014 binary read/write helpers.\n *\n * Covers roundtrip encode/decode for all integer widths,\n * edge cases (zero, max values, boundary values), offset usage,\n * and concatBytes with various input combinations.\n */\n\nimport {\n  assert,\n  assertEqual,\n  assertDeepEqual,\n  assertBigIntEqual,\n  report,\n} from \"../../tests/harness.js\";\n\nimport {\n  writeUint8,\n  readUint8,\n  writeUint16BE,\n  readUint16BE,\n  writeUint32BE,\n  readUint32BE,\n  writeUint64BE,\n  readUint64BE,\n  concatBytes,\n} from \"../../src/util/bytes.js\";\n\n// ---------------------------------------------------------------------------\n// writeUint8 / readUint8\n// ---------------------------------------------------------------------------\n\n// Roundtrip: typical value\n{\n  const buf = new Uint8Array(4);\n  writeUint8(buf, 0, 42);\n  assertEqual(readUint8(buf, 0), 42, \"uint8 roundtrip value 42\");\n}\n\n// Roundtrip: zero\n{\n  const buf = new Uint8Array(1);\n  writeUint8(buf, 0, 0);\n  assertEqual(readUint8(buf, 0), 0, \"uint8 roundtrip zero\");\n}\n\n// Roundtrip: max value 0xFF\n{\n  const buf = new Uint8Array(1);\n  writeUint8(buf, 0, 0xff);\n  assertEqual(readUint8(buf, 0), 0xff, \"uint8 roundtrip max 0xFF\");\n}\n\n// Roundtrip: boundary value 0x80 (128)\n{\n  const buf = new Uint8Array(1);\n  writeUint8(buf, 0, 0x80);\n  assertEqual(readUint8(buf, 0), 0x80, \"uint8 roundtrip boundary 0x80\");\n}\n\n// Roundtrip: boundary value 0x7F (127)\n{\n  const buf = new Uint8Array(1);\n  writeUint8(buf, 0, 0x7f);\n  assertEqual(readUint8(buf, 0), 0x7f, \"uint8 roundtrip boundary 0x7F\");\n}\n\n// Roundtrip: value 1\n{\n  const buf = new Uint8Array(1);\n  writeUint8(buf, 0, 1);\n  assertEqual(readUint8(buf, 0), 1, \"uint8 roundtrip value 1\");\n}\n\n// Non-zero offset\n{\n  const buf = new Uint8Array(4);\n  writeUint8(buf, 2, 0xab);\n  assertEqual(readUint8(buf, 2), 0xab, \"uint8 non-zero offset\");\n  assertEqual(readUint8(buf, 0), 0, \"uint8 other bytes untouched at 0\");\n  assertEqual(readUint8(buf, 1), 0, \"uint8 other bytes untouched at 1\");\n  assertEqual(readUint8(buf, 3), 0, \"uint8 other bytes untouched at 3\");\n}\n\n// Masking: values above 0xFF should be masked to lower 8 bits\n{\n  const buf = new Uint8Array(1);\n  writeUint8(buf, 0, 0x1ff);\n  assertEqual(readUint8(buf, 0), 0xff, \"uint8 masking 0x1FF -> 0xFF\");\n}\n\n{\n  const buf = new Uint8Array(1);\n  writeUint8(buf, 0, 0x100);\n  assertEqual(readUint8(buf, 0), 0x00, \"uint8 masking 0x100 -> 0x00\");\n}\n\n// Multiple writes at different offsets\n{\n  const buf = new Uint8Array(3);\n  writeUint8(buf, 0, 0x11);\n  writeUint8(buf, 1, 0x22);\n  writeUint8(buf, 2, 0x33);\n  assertEqual(readUint8(buf, 0), 0x11, \"uint8 multi-write offset 0\");\n  assertEqual(readUint8(buf, 1), 0x22, \"uint8 multi-write offset 1\");\n  assertEqual(readUint8(buf, 2), 0x33, \"uint8 multi-write offset 2\");\n}\n\n// ---------------------------------------------------------------------------\n// writeUint16BE / readUint16BE\n// ---------------------------------------------------------------------------\n\n// Roundtrip: typical value\n{\n  const buf = new Uint8Array(4);\n  writeUint16BE(buf, 0, 1000);\n  assertEqual(readUint16BE(buf, 0), 1000, \"uint16BE roundtrip value 1000\");\n}\n\n// Roundtrip: zero\n{\n  const buf = new Uint8Array(2);\n  writeUint16BE(buf, 0, 0);\n  assertEqual(readUint16BE(buf, 0), 0, \"uint16BE roundtrip zero\");\n}\n\n// Roundtrip: max value 0xFFFF\n{\n  const buf = new Uint8Array(2);\n  writeUint16BE(buf, 0, 0xffff);\n  assertEqual(readUint16BE(buf, 0), 0xffff, \"uint16BE roundtrip max 0xFFFF\");\n}\n\n// Roundtrip: value 1\n{\n  const buf = new Uint8Array(2);\n  writeUint16BE(buf, 0, 1);\n  assertEqual(readUint16BE(buf, 0), 1, \"uint16BE roundtrip value 1\");\n}\n\n// Roundtrip: boundary 0x0100 (256)\n{\n  const buf = new Uint8Array(2);\n  writeUint16BE(buf, 0, 0x0100);\n  assertEqual(readUint16BE(buf, 0), 0x0100, \"uint16BE roundtrip boundary 0x0100\");\n}\n\n// Roundtrip: boundary 0x00FF (255)\n{\n  const buf = new Uint8Array(2);\n  writeUint16BE(buf, 0, 0x00ff);\n  assertEqual(readUint16BE(buf, 0), 0x00ff, \"uint16BE roundtrip boundary 0x00FF\");\n}\n\n// Roundtrip: boundary 0x8000 (32768)\n{\n  const buf = new Uint8Array(2);\n  writeUint16BE(buf, 0, 0x8000);\n  assertEqual(readUint16BE(buf, 0), 0x8000, \"uint16BE roundtrip boundary 0x8000\");\n}\n\n// Roundtrip: boundary 0x7FFF (32767)\n{\n  const buf = new Uint8Array(2);\n  writeUint16BE(buf, 0, 0x7fff);\n  assertEqual(readUint16BE(buf, 0), 0x7fff, \"uint16BE roundtrip boundary 0x7FFF\");\n}\n\n// Big-endian byte order verification\n{\n  const buf = new Uint8Array(2);\n  writeUint16BE(buf, 0, 0x0102);\n  assertEqual(buf[0], 0x01, \"uint16BE big-endian high byte\");\n  assertEqual(buf[1], 0x02, \"uint16BE big-endian low byte\");\n}\n\n// Non-zero offset\n{\n  const buf = new Uint8Array(6);\n  writeUint16BE(buf, 3, 0xabcd);\n  assertEqual(readUint16BE(buf, 3), 0xabcd, \"uint16BE non-zero offset\");\n  assertEqual(buf[0], 0, \"uint16BE other bytes untouched\");\n  assertEqual(buf[1], 0, \"uint16BE other bytes untouched\");\n  assertEqual(buf[2], 0, \"uint16BE other bytes untouched\");\n  assertEqual(buf[5], 0, \"uint16BE other bytes untouched\");\n}\n\n// Multiple writes at different offsets\n{\n  const buf = new Uint8Array(6);\n  writeUint16BE(buf, 0, 0x1234);\n  writeUint16BE(buf, 2, 0x5678);\n  writeUint16BE(buf, 4, 0x9abc);\n  assertEqual(readUint16BE(buf, 0), 0x1234, \"uint16BE multi-write offset 0\");\n  assertEqual(readUint16BE(buf, 2), 0x5678, \"uint16BE multi-write offset 2\");\n  assertEqual(readUint16BE(buf, 4), 0x9abc, \"uint16BE multi-write offset 4\");\n}\n\n// ---------------------------------------------------------------------------\n// writeUint32BE / readUint32BE\n// ---------------------------------------------------------------------------\n\n// Roundtrip: typical value\n{\n  const buf = new Uint8Array(8);\n  writeUint32BE(buf, 0, 100000);\n  assertEqual(readUint32BE(buf, 0), 100000, \"uint32BE roundtrip value 100000\");\n}\n\n// Roundtrip: zero\n{\n  const buf = new Uint8Array(4);\n  writeUint32BE(buf, 0, 0);\n  assertEqual(readUint32BE(buf, 0), 0, \"uint32BE roundtrip zero\");\n}\n\n// Roundtrip: max value 0xFFFFFFFF\n{\n  const buf = new Uint8Array(4);\n  writeUint32BE(buf, 0, 0xffffffff);\n  assertEqual(readUint32BE(buf, 0), 0xffffffff, \"uint32BE roundtrip max 0xFFFFFFFF\");\n}\n\n// Roundtrip: value 1\n{\n  const buf = new Uint8Array(4);\n  writeUint32BE(buf, 0, 1);\n  assertEqual(readUint32BE(buf, 0), 1, \"uint32BE roundtrip value 1\");\n}\n\n// Roundtrip: boundary 0x00010000 (65536)\n{\n  const buf = new Uint8Array(4);\n  writeUint32BE(buf, 0, 0x00010000);\n  assertEqual(readUint32BE(buf, 0), 0x00010000, \"uint32BE roundtrip boundary 0x00010000\");\n}\n\n// Roundtrip: boundary 0x0000FFFF (65535)\n{\n  const buf = new Uint8Array(4);\n  writeUint32BE(buf, 0, 0x0000ffff);\n  assertEqual(readUint32BE(buf, 0), 0x0000ffff, \"uint32BE roundtrip boundary 0x0000FFFF\");\n}\n\n// Roundtrip: boundary 0x80000000 (2147483648)\n{\n  const buf = new Uint8Array(4);\n  writeUint32BE(buf, 0, 0x80000000);\n  assertEqual(readUint32BE(buf, 0), 0x80000000, \"uint32BE roundtrip boundary 0x80000000\");\n}\n\n// Roundtrip: boundary 0x7FFFFFFF (2147483647)\n{\n  const buf = new Uint8Array(4);\n  writeUint32BE(buf, 0, 0x7fffffff);\n  assertEqual(readUint32BE(buf, 0), 0x7fffffff, \"uint32BE roundtrip boundary 0x7FFFFFFF\");\n}\n\n// Big-endian byte order verification\n{\n  const buf = new Uint8Array(4);\n  writeUint32BE(buf, 0, 0x01020304);\n  assertEqual(buf[0], 0x01, \"uint32BE big-endian byte 0\");\n  assertEqual(buf[1], 0x02, \"uint32BE big-endian byte 1\");\n  assertEqual(buf[2], 0x03, \"uint32BE big-endian byte 2\");\n  assertEqual(buf[3], 0x04, \"uint32BE big-endian byte 3\");\n}\n\n// Non-zero offset\n{\n  const buf = new Uint8Array(8);\n  writeUint32BE(buf, 4, 0xdeadbeef);\n  assertEqual(readUint32BE(buf, 4), 0xdeadbeef, \"uint32BE non-zero offset\");\n  assertEqual(readUint32BE(buf, 0), 0, \"uint32BE other bytes untouched\");\n}\n\n// Multiple writes at adjacent offsets\n{\n  const buf = new Uint8Array(8);\n  writeUint32BE(buf, 0, 0x11223344);\n  writeUint32BE(buf, 4, 0x55667788);\n  assertEqual(readUint32BE(buf, 0), 0x11223344, \"uint32BE multi-write offset 0\");\n  assertEqual(readUint32BE(buf, 4), 0x55667788, \"uint32BE multi-write offset 4\");\n}\n\n// Argon2 time_cost value (relevant to container format)\n{\n  const buf = new Uint8Array(4);\n  writeUint32BE(buf, 0, 3);\n  assertEqual(readUint32BE(buf, 0), 3, \"uint32BE Argon2 time_cost value 3\");\n}\n\n// Argon2 memory_cost value (relevant to container format)\n{\n  const buf = new Uint8Array(4);\n  writeUint32BE(buf, 0, 65536);\n  assertEqual(readUint32BE(buf, 0), 65536, \"uint32BE Argon2 memory_cost 64 MiB\");\n}\n\n// ---------------------------------------------------------------------------\n// writeUint64BE / readUint64BE\n// ---------------------------------------------------------------------------\n\n// Roundtrip: typical value\n{\n  const buf = new Uint8Array(16);\n  writeUint64BE(buf, 0, 1000000n);\n  assertBigIntEqual(readUint64BE(buf, 0), 1000000n, \"uint64BE roundtrip value 1000000\");\n}\n\n// Roundtrip: zero\n{\n  const buf = new Uint8Array(8);\n  writeUint64BE(buf, 0, 0n);\n  assertBigIntEqual(readUint64BE(buf, 0), 0n, \"uint64BE roundtrip zero\");\n}\n\n// Roundtrip: value 1\n{\n  const buf = new Uint8Array(8);\n  writeUint64BE(buf, 0, 1n);\n  assertBigIntEqual(readUint64BE(buf, 0), 1n, \"uint64BE roundtrip value 1\");\n}\n\n// Roundtrip: max value 2^64 - 1\n{\n  const buf = new Uint8Array(8);\n  const maxUint64 = 0xffffffffffffffffn;\n  writeUint64BE(buf, 0, maxUint64);\n  assertBigIntEqual(readUint64BE(buf, 0), maxUint64, \"uint64BE roundtrip max 2^64-1\");\n}\n\n// Roundtrip: 2^32 (exceeds uint32 range, needs uint64)\n{\n  const buf = new Uint8Array(8);\n  writeUint64BE(buf, 0, 0x100000000n);\n  assertBigIntEqual(readUint64BE(buf, 0), 0x100000000n, \"uint64BE roundtrip 2^32\");\n}\n\n// Roundtrip: 2^32 - 1 (max uint32 as bigint)\n{\n  const buf = new Uint8Array(8);\n  writeUint64BE(buf, 0, 0xffffffffn);\n  assertBigIntEqual(readUint64BE(buf, 0), 0xffffffffn, \"uint64BE roundtrip 2^32-1\");\n}\n\n// Roundtrip: boundary 0x8000000000000000 (2^63)\n{\n  const buf = new Uint8Array(8);\n  writeUint64BE(buf, 0, 0x8000000000000000n);\n  assertBigIntEqual(\n    readUint64BE(buf, 0),\n    0x8000000000000000n,\n    \"uint64BE roundtrip boundary 2^63\",\n  );\n}\n\n// Roundtrip: boundary 0x7FFFFFFFFFFFFFFF (2^63 - 1)\n{\n  const buf = new Uint8Array(8);\n  writeUint64BE(buf, 0, 0x7fffffffffffffffn);\n  assertBigIntEqual(\n    readUint64BE(buf, 0),\n    0x7fffffffffffffffn,\n    \"uint64BE roundtrip boundary 2^63-1\",\n  );\n}\n\n// Big-endian byte order verification\n{\n  const buf = new Uint8Array(8);\n  writeUint64BE(buf, 0, 0x0102030405060708n);\n  assertEqual(buf[0], 0x01, \"uint64BE big-endian byte 0\");\n  assertEqual(buf[1], 0x02, \"uint64BE big-endian byte 1\");\n  assertEqual(buf[2], 0x03, \"uint64BE big-endian byte 2\");\n  assertEqual(buf[3], 0x04, \"uint64BE big-endian byte 3\");\n  assertEqual(buf[4], 0x05, \"uint64BE big-endian byte 4\");\n  assertEqual(buf[5], 0x06, \"uint64BE big-endian byte 5\");\n  assertEqual(buf[6], 0x07, \"uint64BE big-endian byte 6\");\n  assertEqual(buf[7], 0x08, \"uint64BE big-endian byte 7\");\n}\n\n// Non-zero offset\n{\n  const buf = new Uint8Array(16);\n  writeUint64BE(buf, 8, 0xdeadbeefcafebaben);\n  assertBigIntEqual(\n    readUint64BE(buf, 8),\n    0xdeadbeefcafebaben,\n    \"uint64BE non-zero offset\",\n  );\n  assertBigIntEqual(readUint64BE(buf, 0), 0n, \"uint64BE other bytes untouched\");\n}\n\n// Large file size value (relevant to container format - original file size field)\n{\n  const buf = new Uint8Array(8);\n  const fourGiB = 4n * 1024n * 1024n * 1024n; // 4 GiB\n  writeUint64BE(buf, 0, fourGiB);\n  assertBigIntEqual(readUint64BE(buf, 0), fourGiB, \"uint64BE large file size 4 GiB\");\n}\n\n// Multiple writes at adjacent offsets\n{\n  const buf = new Uint8Array(16);\n  writeUint64BE(buf, 0, 0x1111111111111111n);\n  writeUint64BE(buf, 8, 0x2222222222222222n);\n  assertBigIntEqual(readUint64BE(buf, 0), 0x1111111111111111n, \"uint64BE multi-write offset 0\");\n  assertBigIntEqual(readUint64BE(buf, 8), 0x2222222222222222n, \"uint64BE multi-write offset 8\");\n}\n\n// ---------------------------------------------------------------------------\n// Mixed-width operations in a single buffer (simulates header layout)\n// ---------------------------------------------------------------------------\n\n{\n  // Simulate a mini container header:\n  // offset 0: version (uint8)\n  // offset 1: kdf_id (uint8)\n  // offset 2: time_cost (uint32BE)\n  // offset 6: memory_cost (uint32BE)\n  // offset 10: parallelism (uint8)\n  // offset 11: salt_len (uint8)\n  // offset 12: filename_len (uint16BE)\n  // offset 14: file_size (uint64BE)\n  // offset 22: ciphertext_len (uint64BE)\n  // Total: 30 bytes\n\n  const header = new Uint8Array(30);\n\n  writeUint8(header, 0, 1); // version\n  writeUint8(header, 1, 1); // kdf_id = Argon2id\n  writeUint32BE(header, 2, 3); // time_cost\n  writeUint32BE(header, 6, 65536); // memory_cost (64 MiB)\n  writeUint8(header, 10, 4); // parallelism\n  writeUint8(header, 11, 16); // salt_len\n  writeUint16BE(header, 12, 0); // filename_len (none)\n  writeUint64BE(header, 14, 2097152n); // file_size (2 MiB)\n  writeUint64BE(header, 22, 2097152n); // ciphertext_len\n\n  assertEqual(readUint8(header, 0), 1, \"header version\");\n  assertEqual(readUint8(header, 1), 1, \"header kdf_id\");\n  assertEqual(readUint32BE(header, 2), 3, \"header time_cost\");\n  assertEqual(readUint32BE(header, 6), 65536, \"header memory_cost\");\n  assertEqual(readUint8(header, 10), 4, \"header parallelism\");\n  assertEqual(readUint8(header, 11), 16, \"header salt_len\");\n  assertEqual(readUint16BE(header, 12), 0, \"header filename_len\");\n  assertBigIntEqual(readUint64BE(header, 14), 2097152n, \"header file_size\");\n  assertBigIntEqual(readUint64BE(header, 22), 2097152n, \"header ciphertext_len\");\n}\n\n// ---------------------------------------------------------------------------\n// concatBytes\n// ---------------------------------------------------------------------------\n\n// No arguments: returns empty Uint8Array\n{\n  const result = concatBytes();\n  assertEqual(result.length, 0, \"concatBytes no args returns empty array\");\n  assert(result instanceof Uint8Array, \"concatBytes no args returns Uint8Array\");\n}\n\n// Single empty array\n{\n  const result = concatBytes(new Uint8Array(0));\n  assertEqual(result.length, 0, \"concatBytes single empty array\");\n}\n\n// Multiple empty arrays\n{\n  const result = concatBytes(new Uint8Array(0), new Uint8Array(0), new Uint8Array(0));\n  assertEqual(result.length, 0, \"concatBytes multiple empty arrays\");\n}\n\n// Single non-empty array\n{\n  const input = new Uint8Array([1, 2, 3]);\n  const result = concatBytes(input);\n  assertDeepEqual(result, new Uint8Array([1, 2, 3]), \"concatBytes single array\");\n}\n\n// Two arrays\n{\n  const a = new Uint8Array([1, 2]);\n  const b = new Uint8Array([3, 4]);\n  const result = concatBytes(a, b);\n  assertDeepEqual(result, new Uint8Array([1, 2, 3, 4]), \"concatBytes two arrays\");\n}\n\n// Three arrays\n{\n  const a = new Uint8Array([0x01]);\n  const b = new Uint8Array([0x02, 0x03]);\n  const c = new Uint8Array([0x04, 0x05, 0x06]);\n  const result = concatBytes(a, b, c);\n  assertDeepEqual(\n    result,\n    new Uint8Array([0x01, 0x02, 0x03, 0x04, 0x05, 0x06]),\n    \"concatBytes three arrays\",\n  );\n}\n\n// Mix of empty and non-empty arrays\n{\n  const a = new Uint8Array(0);\n  const b = new Uint8Array([0xaa, 0xbb]);\n  const c = new Uint8Array(0);\n  const d = new Uint8Array([0xcc]);\n  const e = new Uint8Array(0);\n  const result = concatBytes(a, b, c, d, e);\n  assertDeepEqual(\n    result,\n    new Uint8Array([0xaa, 0xbb, 0xcc]),\n    \"concatBytes mixed empty and non-empty\",\n  );\n}\n\n// Result is a new array (not a view of the original)\n{\n  const a = new Uint8Array([1, 2]);\n  const b = new Uint8Array([3, 4]);\n  const result = concatBytes(a, b);\n\n  // Mutating the result should not affect originals\n  result[0] = 0xff;\n  assertEqual(a[0], 1, \"concatBytes result is independent copy (source unchanged)\");\n\n  // Mutating originals should not affect the result\n  a[1] = 0xee;\n  assertEqual(result[1], 2, \"concatBytes result is independent copy (result unchanged)\");\n}\n\n// Large arrays\n{\n  const size = 1024;\n  const a = new Uint8Array(size);\n  const b = new Uint8Array(size);\n  for (let i = 0; i < size; i++) {\n    a[i] = i & 0xff;\n    b[i] = (size - i) & 0xff;\n  }\n  const result = concatBytes(a, b);\n  assertEqual(result.length, size * 2, \"concatBytes large arrays length\");\n  assertEqual(result[0], 0, \"concatBytes large arrays first byte of a\");\n  assertEqual(result[size - 1], (size - 1) & 0xff, \"concatBytes large arrays last byte of a\");\n  assertEqual(result[size], size & 0xff, \"concatBytes large arrays first byte of b\");\n  assertEqual(result[size * 2 - 1], 1, \"concatBytes large arrays last byte of b\");\n}\n\n// Single-byte arrays\n{\n  const result = concatBytes(\n    new Uint8Array([0x47]),\n    new Uint8Array([0x54]),\n    new Uint8Array([0x4b]),\n    new Uint8Array([0x52]),\n    new Uint8Array([0x59]),\n    new Uint8Array([0x50]),\n    new Uint8Array([0x54]),\n    new Uint8Array([0x00]),\n  );\n  // This spells out GTKRYPT\\0 \u2014 the magic bytes\n  assertDeepEqual(\n    result,\n    new Uint8Array([0x47, 0x54, 0x4b, 0x52, 0x59, 0x50, 0x54, 0x00]),\n    \"concatBytes single-byte arrays form magic bytes\",\n  );\n}\n\n// Preserves all byte values (0x00 through 0xFF)\n{\n  const allBytes = new Uint8Array(256);\n  for (let i = 0; i < 256; i++) {\n    allBytes[i] = i;\n  }\n  const result = concatBytes(allBytes);\n  assertEqual(result.length, 256, \"concatBytes preserves all 256 byte values length\");\n  let allMatch = true;\n  for (let i = 0; i < 256; i++) {\n    if (result[i] !== i) {\n      allMatch = false;\n      break;\n    }\n  }\n  assert(allMatch, \"concatBytes preserves all 256 byte values\");\n}\n\n// ---------------------------------------------------------------------------\n// Report\n// ---------------------------------------------------------------------------\n\nreport(\"bytes\");\n"],
  "mappings": ";AAOA,IAAI,UAAU;AACd,IAAI,UAAU;AACd,IAAM,UAAoB,CAAC;AAEpB,SAAS,OAAO,WAAoB,SAAuB;AAChE,MAAI,WAAW;AACb;AAAA,EACF,OAAO;AACL;AACA,YAAQ,KAAK,WAAW,OAAO,EAAE;AAAA,EACnC;AACF;AAEO,SAAS,YAAe,QAAW,UAAa,SAAuB;AAC5E,MAAI,WAAW,UAAU;AACvB;AAAA,EACF,OAAO;AACL;AACA,YAAQ,KAAK,WAAW,OAAO;AAAA,gBAAmB,OAAO,QAAQ,CAAC;AAAA,gBAAmB,OAAO,MAAM,CAAC,EAAE;AAAA,EACvG;AACF;AAEO,SAAS,gBAAgB,QAAoB,UAAsB,SAAuB;AAC/F,MAAI,OAAO,WAAW,SAAS,QAAQ;AACrC;AACA,YAAQ,KAAK,WAAW,OAAO;AAAA,gCAAmC,SAAS,MAAM,SAAS,OAAO,MAAM,EAAE;AACzG;AAAA,EACF;AACA,WAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,KAAK;AACtC,QAAI,OAAO,CAAC,MAAM,SAAS,CAAC,GAAG;AAC7B;AACA,cAAQ,KAAK,WAAW,OAAO;AAAA,WAAc,CAAC,sBAAsB,SAAS,CAAC,CAAC,SAAS,OAAO,CAAC,CAAC,EAAE;AACnG;AAAA,IACF;AAAA,EACF;AACA;AACF;AAkBO,SAAS,kBAAkB,QAAgB,UAAkB,SAAuB;AACzF,MAAI,WAAW,UAAU;AACvB;AAAA,EACF,OAAO;AACL;AACA,YAAQ,KAAK,WAAW,OAAO;AAAA,gBAAmB,OAAO,QAAQ,CAAC;AAAA,gBAAmB,OAAO,MAAM,CAAC,EAAE;AAAA,EACvG;AACF;AAEO,SAAS,OAAO,WAAyB;AAC9C,MAAI,QAAQ,SAAS,GAAG;AACtB,aAAS;AAAA,EAAK,SAAS,GAAG;AAC1B,eAAW,OAAO,SAAS;AACzB,eAAS,GAAG;AAAA,IACd;AAAA,EACF;AACA,QAAM,GAAG,SAAS,KAAK,OAAO,YAAY,OAAO,SAAS;AAC1D,MAAI,UAAU,GAAG;AACf,YAAQ,OAAO,KAAK,CAAC;AAAA,EACvB;AACF;;;ACtEO,SAAS,WACd,QACA,QACA,OACM;AACN,SAAO,MAAM,IAAI,QAAQ;AAC3B;AAKO,SAAS,cACd,QACA,QACA,OACM;AACN,QAAM,OAAO,IAAI,SAAS,OAAO,QAAQ,OAAO,YAAY,OAAO,UAAU;AAC7E,OAAK,UAAU,QAAQ,OAAO,KAAK;AACrC;AAKO,SAAS,cACd,QACA,QACA,OACM;AACN,QAAM,OAAO,IAAI,SAAS,OAAO,QAAQ,OAAO,YAAY,OAAO,UAAU;AAC7E,OAAK,UAAU,QAAQ,OAAO,KAAK;AACrC;AAQO,SAAS,cACd,QACA,QACA,OACM;AACN,QAAM,OAAO,IAAI,SAAS,OAAO,QAAQ,OAAO,YAAY,OAAO,UAAU;AAC7E,OAAK,aAAa,QAAQ,OAAO,KAAK;AACxC;AAKO,SAAS,UAAU,QAAoB,QAAwB;AACpE,SAAO,OAAO,MAAM;AACtB;AAKO,SAAS,aAAa,QAAoB,QAAwB;AACvE,QAAM,OAAO,IAAI,SAAS,OAAO,QAAQ,OAAO,YAAY,OAAO,UAAU;AAC7E,SAAO,KAAK,UAAU,QAAQ,KAAK;AACrC;AAKO,SAAS,aAAa,QAAoB,QAAwB;AACvE,QAAM,OAAO,IAAI,SAAS,OAAO,QAAQ,OAAO,YAAY,OAAO,UAAU;AAC7E,SAAO,KAAK,UAAU,QAAQ,KAAK;AACrC;AAQO,SAAS,aAAa,QAAoB,QAAwB;AACvE,QAAM,OAAO,IAAI,SAAS,OAAO,QAAQ,OAAO,YAAY,OAAO,UAAU;AAC7E,SAAO,KAAK,aAAa,QAAQ,KAAK;AACxC;AAOO,SAAS,eAAe,QAAkC;AAC/D,MAAI,cAAc;AAClB,aAAW,OAAO,QAAQ;AACxB,mBAAe,IAAI;AAAA,EACrB;AAEA,QAAM,SAAS,IAAI,WAAW,WAAW;AACzC,MAAI,SAAS;AACb,aAAW,OAAO,QAAQ;AACxB,WAAO,IAAI,KAAK,MAAM;AACtB,cAAU,IAAI;AAAA,EAChB;AAEA,SAAO;AACT;;;AC9EA;AACE,QAAM,MAAM,IAAI,WAAW,CAAC;AAC5B,aAAW,KAAK,GAAG,EAAE;AACrB,cAAY,UAAU,KAAK,CAAC,GAAG,IAAI,0BAA0B;AAC/D;AAGA;AACE,QAAM,MAAM,IAAI,WAAW,CAAC;AAC5B,aAAW,KAAK,GAAG,CAAC;AACpB,cAAY,UAAU,KAAK,CAAC,GAAG,GAAG,sBAAsB;AAC1D;AAGA;AACE,QAAM,MAAM,IAAI,WAAW,CAAC;AAC5B,aAAW,KAAK,GAAG,GAAI;AACvB,cAAY,UAAU,KAAK,CAAC,GAAG,KAAM,0BAA0B;AACjE;AAGA;AACE,QAAM,MAAM,IAAI,WAAW,CAAC;AAC5B,aAAW,KAAK,GAAG,GAAI;AACvB,cAAY,UAAU,KAAK,CAAC,GAAG,KAAM,+BAA+B;AACtE;AAGA;AACE,QAAM,MAAM,IAAI,WAAW,CAAC;AAC5B,aAAW,KAAK,GAAG,GAAI;AACvB,cAAY,UAAU,KAAK,CAAC,GAAG,KAAM,+BAA+B;AACtE;AAGA;AACE,QAAM,MAAM,IAAI,WAAW,CAAC;AAC5B,aAAW,KAAK,GAAG,CAAC;AACpB,cAAY,UAAU,KAAK,CAAC,GAAG,GAAG,yBAAyB;AAC7D;AAGA;AACE,QAAM,MAAM,IAAI,WAAW,CAAC;AAC5B,aAAW,KAAK,GAAG,GAAI;AACvB,cAAY,UAAU,KAAK,CAAC,GAAG,KAAM,uBAAuB;AAC5D,cAAY,UAAU,KAAK,CAAC,GAAG,GAAG,kCAAkC;AACpE,cAAY,UAAU,KAAK,CAAC,GAAG,GAAG,kCAAkC;AACpE,cAAY,UAAU,KAAK,CAAC,GAAG,GAAG,kCAAkC;AACtE;AAGA;AACE,QAAM,MAAM,IAAI,WAAW,CAAC;AAC5B,aAAW,KAAK,GAAG,GAAK;AACxB,cAAY,UAAU,KAAK,CAAC,GAAG,KAAM,6BAA6B;AACpE;AAEA;AACE,QAAM,MAAM,IAAI,WAAW,CAAC;AAC5B,aAAW,KAAK,GAAG,GAAK;AACxB,cAAY,UAAU,KAAK,CAAC,GAAG,GAAM,6BAA6B;AACpE;AAGA;AACE,QAAM,MAAM,IAAI,WAAW,CAAC;AAC5B,aAAW,KAAK,GAAG,EAAI;AACvB,aAAW,KAAK,GAAG,EAAI;AACvB,aAAW,KAAK,GAAG,EAAI;AACvB,cAAY,UAAU,KAAK,CAAC,GAAG,IAAM,4BAA4B;AACjE,cAAY,UAAU,KAAK,CAAC,GAAG,IAAM,4BAA4B;AACjE,cAAY,UAAU,KAAK,CAAC,GAAG,IAAM,4BAA4B;AACnE;AAOA;AACE,QAAM,MAAM,IAAI,WAAW,CAAC;AAC5B,gBAAc,KAAK,GAAG,GAAI;AAC1B,cAAY,aAAa,KAAK,CAAC,GAAG,KAAM,+BAA+B;AACzE;AAGA;AACE,QAAM,MAAM,IAAI,WAAW,CAAC;AAC5B,gBAAc,KAAK,GAAG,CAAC;AACvB,cAAY,aAAa,KAAK,CAAC,GAAG,GAAG,yBAAyB;AAChE;AAGA;AACE,QAAM,MAAM,IAAI,WAAW,CAAC;AAC5B,gBAAc,KAAK,GAAG,KAAM;AAC5B,cAAY,aAAa,KAAK,CAAC,GAAG,OAAQ,+BAA+B;AAC3E;AAGA;AACE,QAAM,MAAM,IAAI,WAAW,CAAC;AAC5B,gBAAc,KAAK,GAAG,CAAC;AACvB,cAAY,aAAa,KAAK,CAAC,GAAG,GAAG,4BAA4B;AACnE;AAGA;AACE,QAAM,MAAM,IAAI,WAAW,CAAC;AAC5B,gBAAc,KAAK,GAAG,GAAM;AAC5B,cAAY,aAAa,KAAK,CAAC,GAAG,KAAQ,oCAAoC;AAChF;AAGA;AACE,QAAM,MAAM,IAAI,WAAW,CAAC;AAC5B,gBAAc,KAAK,GAAG,GAAM;AAC5B,cAAY,aAAa,KAAK,CAAC,GAAG,KAAQ,oCAAoC;AAChF;AAGA;AACE,QAAM,MAAM,IAAI,WAAW,CAAC;AAC5B,gBAAc,KAAK,GAAG,KAAM;AAC5B,cAAY,aAAa,KAAK,CAAC,GAAG,OAAQ,oCAAoC;AAChF;AAGA;AACE,QAAM,MAAM,IAAI,WAAW,CAAC;AAC5B,gBAAc,KAAK,GAAG,KAAM;AAC5B,cAAY,aAAa,KAAK,CAAC,GAAG,OAAQ,oCAAoC;AAChF;AAGA;AACE,QAAM,MAAM,IAAI,WAAW,CAAC;AAC5B,gBAAc,KAAK,GAAG,GAAM;AAC5B,cAAY,IAAI,CAAC,GAAG,GAAM,+BAA+B;AACzD,cAAY,IAAI,CAAC,GAAG,GAAM,8BAA8B;AAC1D;AAGA;AACE,QAAM,MAAM,IAAI,WAAW,CAAC;AAC5B,gBAAc,KAAK,GAAG,KAAM;AAC5B,cAAY,aAAa,KAAK,CAAC,GAAG,OAAQ,0BAA0B;AACpE,cAAY,IAAI,CAAC,GAAG,GAAG,gCAAgC;AACvD,cAAY,IAAI,CAAC,GAAG,GAAG,gCAAgC;AACvD,cAAY,IAAI,CAAC,GAAG,GAAG,gCAAgC;AACvD,cAAY,IAAI,CAAC,GAAG,GAAG,gCAAgC;AACzD;AAGA;AACE,QAAM,MAAM,IAAI,WAAW,CAAC;AAC5B,gBAAc,KAAK,GAAG,IAAM;AAC5B,gBAAc,KAAK,GAAG,KAAM;AAC5B,gBAAc,KAAK,GAAG,KAAM;AAC5B,cAAY,aAAa,KAAK,CAAC,GAAG,MAAQ,+BAA+B;AACzE,cAAY,aAAa,KAAK,CAAC,GAAG,OAAQ,+BAA+B;AACzE,cAAY,aAAa,KAAK,CAAC,GAAG,OAAQ,+BAA+B;AAC3E;AAOA;AACE,QAAM,MAAM,IAAI,WAAW,CAAC;AAC5B,gBAAc,KAAK,GAAG,GAAM;AAC5B,cAAY,aAAa,KAAK,CAAC,GAAG,KAAQ,iCAAiC;AAC7E;AAGA;AACE,QAAM,MAAM,IAAI,WAAW,CAAC;AAC5B,gBAAc,KAAK,GAAG,CAAC;AACvB,cAAY,aAAa,KAAK,CAAC,GAAG,GAAG,yBAAyB;AAChE;AAGA;AACE,QAAM,MAAM,IAAI,WAAW,CAAC;AAC5B,gBAAc,KAAK,GAAG,UAAU;AAChC,cAAY,aAAa,KAAK,CAAC,GAAG,YAAY,mCAAmC;AACnF;AAGA;AACE,QAAM,MAAM,IAAI,WAAW,CAAC;AAC5B,gBAAc,KAAK,GAAG,CAAC;AACvB,cAAY,aAAa,KAAK,CAAC,GAAG,GAAG,4BAA4B;AACnE;AAGA;AACE,QAAM,MAAM,IAAI,WAAW,CAAC;AAC5B,gBAAc,KAAK,GAAG,KAAU;AAChC,cAAY,aAAa,KAAK,CAAC,GAAG,OAAY,wCAAwC;AACxF;AAGA;AACE,QAAM,MAAM,IAAI,WAAW,CAAC;AAC5B,gBAAc,KAAK,GAAG,KAAU;AAChC,cAAY,aAAa,KAAK,CAAC,GAAG,OAAY,wCAAwC;AACxF;AAGA;AACE,QAAM,MAAM,IAAI,WAAW,CAAC;AAC5B,gBAAc,KAAK,GAAG,UAAU;AAChC,cAAY,aAAa,KAAK,CAAC,GAAG,YAAY,wCAAwC;AACxF;AAGA;AACE,QAAM,MAAM,IAAI,WAAW,CAAC;AAC5B,gBAAc,KAAK,GAAG,UAAU;AAChC,cAAY,aAAa,KAAK,CAAC,GAAG,YAAY,wCAAwC;AACxF;AAGA;AACE,QAAM,MAAM,IAAI,WAAW,CAAC;AAC5B,gBAAc,KAAK,GAAG,QAAU;AAChC,cAAY,IAAI,CAAC,GAAG,GAAM,4BAA4B;AACtD,cAAY,IAAI,CAAC,GAAG,GAAM,4BAA4B;AACtD,cAAY,IAAI,CAAC,GAAG,GAAM,4BAA4B;AACtD,cAAY,IAAI,CAAC,GAAG,GAAM,4BAA4B;AACxD;AAGA;AACE,QAAM,MAAM,IAAI,WAAW,CAAC;AAC5B,gBAAc,KAAK,GAAG,UAAU;AAChC,cAAY,aAAa,KAAK,CAAC,GAAG,YAAY,0BAA0B;AACxE,cAAY,aAAa,KAAK,CAAC,GAAG,GAAG,gCAAgC;AACvE;AAGA;AACE,QAAM,MAAM,IAAI,WAAW,CAAC;AAC5B,gBAAc,KAAK,GAAG,SAAU;AAChC,gBAAc,KAAK,GAAG,UAAU;AAChC,cAAY,aAAa,KAAK,CAAC,GAAG,WAAY,+BAA+B;AAC7E,cAAY,aAAa,KAAK,CAAC,GAAG,YAAY,+BAA+B;AAC/E;AAGA;AACE,QAAM,MAAM,IAAI,WAAW,CAAC;AAC5B,gBAAc,KAAK,GAAG,CAAC;AACvB,cAAY,aAAa,KAAK,CAAC,GAAG,GAAG,mCAAmC;AAC1E;AAGA;AACE,QAAM,MAAM,IAAI,WAAW,CAAC;AAC5B,gBAAc,KAAK,GAAG,KAAK;AAC3B,cAAY,aAAa,KAAK,CAAC,GAAG,OAAO,oCAAoC;AAC/E;AAOA;AACE,QAAM,MAAM,IAAI,WAAW,EAAE;AAC7B,gBAAc,KAAK,GAAG,QAAQ;AAC9B,oBAAkB,aAAa,KAAK,CAAC,GAAG,UAAU,kCAAkC;AACtF;AAGA;AACE,QAAM,MAAM,IAAI,WAAW,CAAC;AAC5B,gBAAc,KAAK,GAAG,EAAE;AACxB,oBAAkB,aAAa,KAAK,CAAC,GAAG,IAAI,yBAAyB;AACvE;AAGA;AACE,QAAM,MAAM,IAAI,WAAW,CAAC;AAC5B,gBAAc,KAAK,GAAG,EAAE;AACxB,oBAAkB,aAAa,KAAK,CAAC,GAAG,IAAI,4BAA4B;AAC1E;AAGA;AACE,QAAM,MAAM,IAAI,WAAW,CAAC;AAC5B,QAAM,YAAY;AAClB,gBAAc,KAAK,GAAG,SAAS;AAC/B,oBAAkB,aAAa,KAAK,CAAC,GAAG,WAAW,+BAA+B;AACpF;AAGA;AACE,QAAM,MAAM,IAAI,WAAW,CAAC;AAC5B,gBAAc,KAAK,GAAG,YAAY;AAClC,oBAAkB,aAAa,KAAK,CAAC,GAAG,cAAc,yBAAyB;AACjF;AAGA;AACE,QAAM,MAAM,IAAI,WAAW,CAAC;AAC5B,gBAAc,KAAK,GAAG,WAAW;AACjC,oBAAkB,aAAa,KAAK,CAAC,GAAG,aAAa,2BAA2B;AAClF;AAGA;AACE,QAAM,MAAM,IAAI,WAAW,CAAC;AAC5B,gBAAc,KAAK,GAAG,mBAAmB;AACzC;AAAA,IACE,aAAa,KAAK,CAAC;AAAA,IACnB;AAAA,IACA;AAAA,EACF;AACF;AAGA;AACE,QAAM,MAAM,IAAI,WAAW,CAAC;AAC5B,gBAAc,KAAK,GAAG,mBAAmB;AACzC;AAAA,IACE,aAAa,KAAK,CAAC;AAAA,IACnB;AAAA,IACA;AAAA,EACF;AACF;AAGA;AACE,QAAM,MAAM,IAAI,WAAW,CAAC;AAC5B,gBAAc,KAAK,GAAG,mBAAmB;AACzC,cAAY,IAAI,CAAC,GAAG,GAAM,4BAA4B;AACtD,cAAY,IAAI,CAAC,GAAG,GAAM,4BAA4B;AACtD,cAAY,IAAI,CAAC,GAAG,GAAM,4BAA4B;AACtD,cAAY,IAAI,CAAC,GAAG,GAAM,4BAA4B;AACtD,cAAY,IAAI,CAAC,GAAG,GAAM,4BAA4B;AACtD,cAAY,IAAI,CAAC,GAAG,GAAM,4BAA4B;AACtD,cAAY,IAAI,CAAC,GAAG,GAAM,4BAA4B;AACtD,cAAY,IAAI,CAAC,GAAG,GAAM,4BAA4B;AACxD;AAGA;AACE,QAAM,MAAM,IAAI,WAAW,EAAE;AAC7B,gBAAc,KAAK,GAAG,mBAAmB;AACzC;AAAA,IACE,aAAa,KAAK,CAAC;AAAA,IACnB;AAAA,IACA;AAAA,EACF;AACA,oBAAkB,aAAa,KAAK,CAAC,GAAG,IAAI,gCAAgC;AAC9E;AAGA;AACE,QAAM,MAAM,IAAI,WAAW,CAAC;AAC5B,QAAM,UAAU,KAAK,QAAQ,QAAQ;AACrC,gBAAc,KAAK,GAAG,OAAO;AAC7B,oBAAkB,aAAa,KAAK,CAAC,GAAG,SAAS,gCAAgC;AACnF;AAGA;AACE,QAAM,MAAM,IAAI,WAAW,EAAE;AAC7B,gBAAc,KAAK,GAAG,mBAAmB;AACzC,gBAAc,KAAK,GAAG,mBAAmB;AACzC,oBAAkB,aAAa,KAAK,CAAC,GAAG,qBAAqB,+BAA+B;AAC5F,oBAAkB,aAAa,KAAK,CAAC,GAAG,qBAAqB,+BAA+B;AAC9F;AAMA;AAaE,QAAM,SAAS,IAAI,WAAW,EAAE;AAEhC,aAAW,QAAQ,GAAG,CAAC;AACvB,aAAW,QAAQ,GAAG,CAAC;AACvB,gBAAc,QAAQ,GAAG,CAAC;AAC1B,gBAAc,QAAQ,GAAG,KAAK;AAC9B,aAAW,QAAQ,IAAI,CAAC;AACxB,aAAW,QAAQ,IAAI,EAAE;AACzB,gBAAc,QAAQ,IAAI,CAAC;AAC3B,gBAAc,QAAQ,IAAI,QAAQ;AAClC,gBAAc,QAAQ,IAAI,QAAQ;AAElC,cAAY,UAAU,QAAQ,CAAC,GAAG,GAAG,gBAAgB;AACrD,cAAY,UAAU,QAAQ,CAAC,GAAG,GAAG,eAAe;AACpD,cAAY,aAAa,QAAQ,CAAC,GAAG,GAAG,kBAAkB;AAC1D,cAAY,aAAa,QAAQ,CAAC,GAAG,OAAO,oBAAoB;AAChE,cAAY,UAAU,QAAQ,EAAE,GAAG,GAAG,oBAAoB;AAC1D,cAAY,UAAU,QAAQ,EAAE,GAAG,IAAI,iBAAiB;AACxD,cAAY,aAAa,QAAQ,EAAE,GAAG,GAAG,qBAAqB;AAC9D,oBAAkB,aAAa,QAAQ,EAAE,GAAG,UAAU,kBAAkB;AACxE,oBAAkB,aAAa,QAAQ,EAAE,GAAG,UAAU,uBAAuB;AAC/E;AAOA;AACE,QAAM,SAAS,YAAY;AAC3B,cAAY,OAAO,QAAQ,GAAG,yCAAyC;AACvE,SAAO,kBAAkB,YAAY,wCAAwC;AAC/E;AAGA;AACE,QAAM,SAAS,YAAY,IAAI,WAAW,CAAC,CAAC;AAC5C,cAAY,OAAO,QAAQ,GAAG,gCAAgC;AAChE;AAGA;AACE,QAAM,SAAS,YAAY,IAAI,WAAW,CAAC,GAAG,IAAI,WAAW,CAAC,GAAG,IAAI,WAAW,CAAC,CAAC;AAClF,cAAY,OAAO,QAAQ,GAAG,mCAAmC;AACnE;AAGA;AACE,QAAM,QAAQ,IAAI,WAAW,CAAC,GAAG,GAAG,CAAC,CAAC;AACtC,QAAM,SAAS,YAAY,KAAK;AAChC,kBAAgB,QAAQ,IAAI,WAAW,CAAC,GAAG,GAAG,CAAC,CAAC,GAAG,0BAA0B;AAC/E;AAGA;AACE,QAAM,IAAI,IAAI,WAAW,CAAC,GAAG,CAAC,CAAC;AAC/B,QAAM,IAAI,IAAI,WAAW,CAAC,GAAG,CAAC,CAAC;AAC/B,QAAM,SAAS,YAAY,GAAG,CAAC;AAC/B,kBAAgB,QAAQ,IAAI,WAAW,CAAC,GAAG,GAAG,GAAG,CAAC,CAAC,GAAG,wBAAwB;AAChF;AAGA;AACE,QAAM,IAAI,IAAI,WAAW,CAAC,CAAI,CAAC;AAC/B,QAAM,IAAI,IAAI,WAAW,CAAC,GAAM,CAAI,CAAC;AACrC,QAAM,IAAI,IAAI,WAAW,CAAC,GAAM,GAAM,CAAI,CAAC;AAC3C,QAAM,SAAS,YAAY,GAAG,GAAG,CAAC;AAClC;AAAA,IACE;AAAA,IACA,IAAI,WAAW,CAAC,GAAM,GAAM,GAAM,GAAM,GAAM,CAAI,CAAC;AAAA,IACnD;AAAA,EACF;AACF;AAGA;AACE,QAAM,IAAI,IAAI,WAAW,CAAC;AAC1B,QAAM,IAAI,IAAI,WAAW,CAAC,KAAM,GAAI,CAAC;AACrC,QAAM,IAAI,IAAI,WAAW,CAAC;AAC1B,QAAM,IAAI,IAAI,WAAW,CAAC,GAAI,CAAC;AAC/B,QAAM,IAAI,IAAI,WAAW,CAAC;AAC1B,QAAM,SAAS,YAAY,GAAG,GAAG,GAAG,GAAG,CAAC;AACxC;AAAA,IACE;AAAA,IACA,IAAI,WAAW,CAAC,KAAM,KAAM,GAAI,CAAC;AAAA,IACjC;AAAA,EACF;AACF;AAGA;AACE,QAAM,IAAI,IAAI,WAAW,CAAC,GAAG,CAAC,CAAC;AAC/B,QAAM,IAAI,IAAI,WAAW,CAAC,GAAG,CAAC,CAAC;AAC/B,QAAM,SAAS,YAAY,GAAG,CAAC;AAG/B,SAAO,CAAC,IAAI;AACZ,cAAY,EAAE,CAAC,GAAG,GAAG,2DAA2D;AAGhF,IAAE,CAAC,IAAI;AACP,cAAY,OAAO,CAAC,GAAG,GAAG,2DAA2D;AACvF;AAGA;AACE,QAAM,OAAO;AACb,QAAM,IAAI,IAAI,WAAW,IAAI;AAC7B,QAAM,IAAI,IAAI,WAAW,IAAI;AAC7B,WAAS,IAAI,GAAG,IAAI,MAAM,KAAK;AAC7B,MAAE,CAAC,IAAI,IAAI;AACX,MAAE,CAAC,IAAK,OAAO,IAAK;AAAA,EACtB;AACA,QAAM,SAAS,YAAY,GAAG,CAAC;AAC/B,cAAY,OAAO,QAAQ,OAAO,GAAG,iCAAiC;AACtE,cAAY,OAAO,CAAC,GAAG,GAAG,0CAA0C;AACpE,cAAY,OAAO,OAAO,CAAC,GAAI,OAAO,IAAK,KAAM,yCAAyC;AAC1F,cAAY,OAAO,IAAI,GAAG,OAAO,KAAM,0CAA0C;AACjF,cAAY,OAAO,OAAO,IAAI,CAAC,GAAG,GAAG,yCAAyC;AAChF;AAGA;AACE,QAAM,SAAS;AAAA,IACb,IAAI,WAAW,CAAC,EAAI,CAAC;AAAA,IACrB,IAAI,WAAW,CAAC,EAAI,CAAC;AAAA,IACrB,IAAI,WAAW,CAAC,EAAI,CAAC;AAAA,IACrB,IAAI,WAAW,CAAC,EAAI,CAAC;AAAA,IACrB,IAAI,WAAW,CAAC,EAAI,CAAC;AAAA,IACrB,IAAI,WAAW,CAAC,EAAI,CAAC;AAAA,IACrB,IAAI,WAAW,CAAC,EAAI,CAAC;AAAA,IACrB,IAAI,WAAW,CAAC,CAAI,CAAC;AAAA,EACvB;AAEA;AAAA,IACE;AAAA,IACA,IAAI,WAAW,CAAC,IAAM,IAAM,IAAM,IAAM,IAAM,IAAM,IAAM,CAAI,CAAC;AAAA,IAC/D;AAAA,EACF;AACF;AAGA;AACE,QAAM,WAAW,IAAI,WAAW,GAAG;AACnC,WAAS,IAAI,GAAG,IAAI,KAAK,KAAK;AAC5B,aAAS,CAAC,IAAI;AAAA,EAChB;AACA,QAAM,SAAS,YAAY,QAAQ;AACnC,cAAY,OAAO,QAAQ,KAAK,kDAAkD;AAClF,MAAI,WAAW;AACf,WAAS,IAAI,GAAG,IAAI,KAAK,KAAK;AAC5B,QAAI,OAAO,CAAC,MAAM,GAAG;AACnB,iBAAW;AACX;AAAA,IACF;AAAA,EACF;AACA,SAAO,UAAU,2CAA2C;AAC9D;AAMA,OAAO,OAAO;",
  "names": []
}

{
  "version": 3,
  "sources": ["../../../tests/harness.ts", "../../../src/services/detect.ts", "../../../src/util/i18n.ts", "../../../src/services/format.ts", "../../../tests/unit/detect.test.ts"],
  "sourcesContent": ["/**\n * Minimal GJS test harness with assertion helpers.\n *\n * Each test file imports from this module, runs assertions, and\n * calls `report()` at the end. Non-zero exit on any failure.\n */\n\nlet _passed = 0;\nlet _failed = 0;\nconst _errors: string[] = [];\n\nexport function assert(condition: boolean, message: string): void {\n  if (condition) {\n    _passed++;\n  } else {\n    _failed++;\n    _errors.push(`  FAIL: ${message}`);\n  }\n}\n\nexport function assertEqual<T>(actual: T, expected: T, message: string): void {\n  if (actual === expected) {\n    _passed++;\n  } else {\n    _failed++;\n    _errors.push(`  FAIL: ${message}\\n    expected: ${String(expected)}\\n    actual:   ${String(actual)}`);\n  }\n}\n\nexport function assertDeepEqual(actual: Uint8Array, expected: Uint8Array, message: string): void {\n  if (actual.length !== expected.length) {\n    _failed++;\n    _errors.push(`  FAIL: ${message}\\n    length mismatch: expected ${expected.length}, got ${actual.length}`);\n    return;\n  }\n  for (let i = 0; i < actual.length; i++) {\n    if (actual[i] !== expected[i]) {\n      _failed++;\n      _errors.push(`  FAIL: ${message}\\n    byte ${i} differs: expected ${expected[i]}, got ${actual[i]}`);\n      return;\n    }\n  }\n  _passed++;\n}\n\nexport function assertThrows(fn: () => void, errorName: string, message: string): void {\n  try {\n    fn();\n    _failed++;\n    _errors.push(`  FAIL: ${message}\\n    expected ${errorName} to be thrown, but nothing was thrown`);\n  } catch (e: unknown) {\n    const err = e as { name?: string };\n    if (err.name === errorName) {\n      _passed++;\n    } else {\n      _failed++;\n      _errors.push(`  FAIL: ${message}\\n    expected ${errorName}, got ${err.name ?? String(e)}`);\n    }\n  }\n}\n\nexport function assertBigIntEqual(actual: bigint, expected: bigint, message: string): void {\n  if (actual === expected) {\n    _passed++;\n  } else {\n    _failed++;\n    _errors.push(`  FAIL: ${message}\\n    expected: ${String(expected)}\\n    actual:   ${String(actual)}`);\n  }\n}\n\nexport function report(suiteName: string): void {\n  if (_errors.length > 0) {\n    printerr(`\\n${suiteName}:`);\n    for (const err of _errors) {\n      printerr(err);\n    }\n  }\n  print(`${suiteName}: ${_passed} passed, ${_failed} failed`);\n  if (_failed > 0) {\n    imports.system.exit(1);\n  }\n}\n", "/**\n * Magic byte detection for `.gtkrypt` files.\n *\n * Reads the first 8 bytes of a file and compares them against the\n * container magic to determine whether the file is encrypted or\n * plaintext. This drives the UI's automatic encrypt-vs-decrypt\n * mode selection.\n */\n\nimport Gio from \"gi://Gio\";\n\nimport { HEADER_MAGIC } from \"./format.js\";\n\n/**\n * Detect whether a file is a `.gtkrypt` encrypted container,\n * an ordinary plaintext file, or indeterminate.\n *\n * Detection is based solely on the first 8 bytes (the magic header).\n * Files that are empty, shorter than 8 bytes, or unreadable are\n * reported as `'unknown'`.\n *\n * @param path - Absolute filesystem path to the file.\n * @returns `'encrypted'` if the magic bytes match, `'plaintext'` if\n *   the file is readable but does not match, or `'unknown'` if the\n *   file cannot be read or is too short.\n */\nexport function detectFileType(\n  path: string,\n): \"plaintext\" | \"encrypted\" | \"unknown\" {\n  try {\n    const file = Gio.File.new_for_path(path);\n    const stream = file.read(null);\n    const gbytes = stream.read_bytes(8, null);\n    stream.close(null);\n\n    const data = gbytes.get_data();\n    if (data === null || data.byteLength < HEADER_MAGIC.length) {\n      return \"unknown\";\n    }\n\n    for (let i = 0; i < HEADER_MAGIC.length; i++) {\n      if (data[i] !== HEADER_MAGIC[i]) {\n        return \"plaintext\";\n      }\n    }\n\n    return \"encrypted\";\n  } catch {\n    return \"unknown\";\n  }\n}\n", "import GLib from \"gi://GLib\";\n\nconst domain = \"gtkrypt\";\n\nimports.gettext.bindtextdomain(domain, GLib.get_home_dir());\nimports.gettext.textdomain(domain);\n\nexport const _ = imports.gettext.gettext;\nexport const ngettext = imports.gettext.ngettext;\n", "/**\n * Container format parser for `.gtkrypt` files (read-only).\n *\n * This module decodes the binary header written by the Rust crypto\n * backend. It is intentionally read-only -- encoding is performed\n * exclusively by the Rust binary to keep the single source of truth\n * for header construction in one place.\n *\n * The byte layout is documented in SCOPE.md under \"Container format\".\n */\n\nimport type { ContainerHeader, KdfParams } from \"../models/types.js\";\nimport {\n  CorruptFileError,\n  UnsupportedVersionError,\n} from \"../models/errors.js\";\nimport {\n  readUint8,\n  readUint16BE,\n  readUint32BE,\n  readUint64BE,\n} from \"../util/bytes.js\";\n\n/** Magic bytes at the start of every `.gtkrypt` file: \"GTKRYPT\\0\". */\nexport const HEADER_MAGIC = new Uint8Array([\n  0x47, 0x54, 0x4b, 0x52, 0x59, 0x50, 0x54, 0x00,\n]);\n\n/** The newest container version this build can read. */\nexport const CURRENT_VERSION = 2;\n\n/** KDF identifier for Argon2id. */\nconst KDF_ARGON2ID = 1;\n\n/** Expected salt length in bytes. */\nconst SALT_LENGTH = 16;\n\n/** Expected nonce/IV length in bytes. */\nconst NONCE_LENGTH = 12;\n\n/** Minimum header sizes (no stored filename). */\nconst MIN_HEADER_SIZE_V1 = 67;\nconst MIN_HEADER_SIZE_V2 = 71;\n\n/**\n * Parse a `.gtkrypt` container header from raw bytes.\n *\n * The caller should pass at least the first `MIN_HEADER_SIZE` bytes of\n * the file (more if a stored filename is present). This function does\n * not read or validate any ciphertext -- only the header fields.\n *\n * @param bytes - Raw bytes from the beginning of a `.gtkrypt` file.\n * @returns The parsed {@link ContainerHeader}.\n * @throws {@link CorruptFileError} if the magic bytes are wrong, the\n *   KDF identifier is unrecognised, or the buffer is too short.\n * @throws {@link UnsupportedVersionError} if the version field does\n *   not match {@link CURRENT_VERSION}.\n */\nexport function parseHeader(bytes: Uint8Array): ContainerHeader {\n  if (bytes.byteLength < MIN_HEADER_SIZE_V1) {\n    throw new CorruptFileError(\"Header too short to be a valid gtkrypt file\");\n  }\n\n  // -- Magic (offset 0, 8 bytes) --\n  for (let i = 0; i < HEADER_MAGIC.length; i++) {\n    if (bytes[i] !== HEADER_MAGIC[i]) {\n      throw new CorruptFileError(\"Invalid magic bytes\");\n    }\n  }\n\n  // -- Version (offset 8, 1 byte) --\n  const version = readUint8(bytes, 8);\n  if (version !== 1 && version !== 2) {\n    throw new UnsupportedVersionError(\n      `Container version ${version} is not supported (expected 1 or ${CURRENT_VERSION})`,\n    );\n  }\n  if (version === 2 && bytes.byteLength < MIN_HEADER_SIZE_V2) {\n    throw new CorruptFileError(\"Header too short to be a valid gtkrypt v2 file\");\n  }\n\n  // -- KDF ID (offset 9, 1 byte) --\n  const kdfId = readUint8(bytes, 9);\n  if (kdfId !== KDF_ARGON2ID) {\n    throw new CorruptFileError(`Unknown KDF identifier: ${kdfId}`);\n  }\n\n  // -- KDF parameters --\n  const timeCost = readUint32BE(bytes, 10);\n  const memoryCost = readUint32BE(bytes, 14);\n  const parallelism = readUint8(bytes, 18);\n\n  const kdfParams: KdfParams = { timeCost, memoryCost, parallelism };\n\n  // -- Salt (offset 19: length, offset 20: data) --\n  const saltLength = readUint8(bytes, 19);\n  if (saltLength !== SALT_LENGTH) {\n    throw new CorruptFileError(\n      `Unexpected salt length: ${saltLength} (expected ${SALT_LENGTH})`,\n    );\n  }\n  const salt = bytes.slice(20, 20 + saltLength);\n\n  // -- Nonce (offset 36: length, offset 37: data) --\n  const nonceLength = readUint8(bytes, 36);\n  if (nonceLength !== NONCE_LENGTH) {\n    throw new CorruptFileError(\n      `Unexpected nonce length: ${nonceLength} (expected ${NONCE_LENGTH})`,\n    );\n  }\n  const nonce = bytes.slice(37, 37 + nonceLength);\n\n  // -- Filename (offset 49: uint16BE length, offset 51: UTF-8 data) --\n  const filenameLength = readUint16BE(bytes, 49);\n\n  const requiredSize =\n    (version === 2 ? MIN_HEADER_SIZE_V2 : MIN_HEADER_SIZE_V1) + filenameLength;\n  if (bytes.byteLength < requiredSize) {\n    throw new CorruptFileError(\n      \"Header too short: filename extends past available bytes\",\n    );\n  }\n\n  let filename = \"\";\n  if (filenameLength > 0) {\n    const decoder = new TextDecoder(\"utf-8\");\n    filename = decoder.decode(bytes.slice(51, 51 + filenameLength));\n  }\n\n  const offset = 51 + filenameLength;\n\n  let mode: number | undefined;\n  let fileSize: bigint;\n  let ciphertextLength: bigint;\n\n  if (version === 2) {\n    // -- Mode (uint32BE at 51 + filenameLength) --\n    mode = readUint32BE(bytes, offset);\n\n    // -- File size (uint64BE at 55 + filenameLength) --\n    fileSize = readUint64BE(bytes, offset + 4);\n\n    // -- Ciphertext length (uint64BE at 63 + filenameLength) --\n    ciphertextLength = readUint64BE(bytes, offset + 12);\n  } else {\n    // -- File size (uint64BE at 51 + filenameLength) --\n    fileSize = readUint64BE(bytes, offset);\n\n    // -- Ciphertext length (uint64BE at 59 + filenameLength) --\n    ciphertextLength = readUint64BE(bytes, offset + 8);\n  }\n\n  return {\n    version,\n    kdfId,\n    kdfParams,\n    salt,\n    nonce,\n    filename,\n    mode,\n    fileSize,\n    ciphertextLength,\n  };\n}\n\n/**\n * Extract the Additional Authenticated Data (AAD) bytes from a header.\n *\n * AAD covers bytes 0 through 48 (inclusive) -- everything from the\n * magic through the end of the nonce. This range is authenticated\n * by GCM to detect header tampering.\n *\n * @param bytes - Raw bytes from the beginning of a `.gtkrypt` file.\n *   Must be at least 49 bytes long.\n * @returns A new Uint8Array containing the AAD region.\n * @throws {@link CorruptFileError} if the buffer is shorter than 49 bytes.\n */\nexport function getAADBytes(bytes: Uint8Array): Uint8Array {\n  const AAD_END = 49;\n  if (bytes.byteLength < AAD_END) {\n    throw new CorruptFileError(\"Buffer too short to extract AAD bytes\");\n  }\n  return bytes.slice(0, AAD_END);\n}\n", "/**\n * Unit tests for magic byte detection (`src/services/detect.ts`).\n *\n * Covers SCOPE.md task 7.4: valid .gtkrypt detection, plaintext,\n * empty files, short files, and nonexistent paths.\n */\n\nimport { assertEqual, report } from \"../../tests/harness.js\";\nimport { detectFileType } from \"../../src/services/detect.js\";\nimport GLib from \"gi://GLib\";\nimport Gio from \"gi://Gio\";\n\n// ---------------------------------------------------------------------------\n// Helpers\n// ---------------------------------------------------------------------------\n\n/** Create a temporary directory for this test run. */\nconst tmpDir = GLib.dir_make_tmp(\"gtkrypt-test-XXXXXX\");\n\n/** Write raw bytes to a file inside the temp directory. */\nfunction writeTempFile(name: string, data: Uint8Array): string {\n  const path = GLib.build_filenamev([tmpDir, name]);\n  const file = Gio.File.new_for_path(path);\n  const stream = file.create(Gio.FileCreateFlags.NONE, null);\n  if (data.byteLength > 0) {\n    stream.write_bytes(new GLib.Bytes(data), null);\n  }\n  stream.close(null);\n  return path;\n}\n\n/** Delete a file at the given path, ignoring errors. */\nfunction removeTempFile(path: string): void {\n  try {\n    Gio.File.new_for_path(path).delete(null);\n  } catch {\n    // Ignore \u2014 file may already be deleted or nonexistent.\n  }\n}\n\n/** Remove the temp directory (must be empty). */\nfunction removeTempDir(): void {\n  try {\n    Gio.File.new_for_path(tmpDir).delete(null);\n  } catch {\n    // Ignore if removal fails.\n  }\n}\n\n// ---------------------------------------------------------------------------\n// Test data\n// ---------------------------------------------------------------------------\n\n/** Valid GTKRYPT magic bytes: \"GTKRYPT\\0\" */\nconst MAGIC = new Uint8Array([0x47, 0x54, 0x4b, 0x52, 0x59, 0x50, 0x54, 0x00]);\n\n// ---------------------------------------------------------------------------\n// Tests\n// ---------------------------------------------------------------------------\n\nconst tempFiles: string[] = [];\n\n// 1. File starting with GTKRYPT\\0 magic bytes + extra data -> 'encrypted'\n{\n  const extra = new Uint8Array([0x01, 0x02, 0x03, 0x04, 0xff, 0xfe]);\n  const data = new Uint8Array(MAGIC.byteLength + extra.byteLength);\n  data.set(MAGIC, 0);\n  data.set(extra, MAGIC.byteLength);\n\n  const path = writeTempFile(\"valid-encrypted.gtkrypt\", data);\n  tempFiles.push(path);\n\n  const result = detectFileType(path);\n  assertEqual(result, \"encrypted\", \"File with valid magic bytes should be detected as encrypted\");\n}\n\n// 2. Plain text file -> 'plaintext'\n{\n  const encoder = new TextEncoder();\n  const data = encoder.encode(\"Hello, this is a plain text file.\\n\");\n\n  const path = writeTempFile(\"plain.txt\", data);\n  tempFiles.push(path);\n\n  const result = detectFileType(path);\n  assertEqual(result, \"plaintext\", \"Plain text file should be detected as plaintext\");\n}\n\n// 3. Empty file (0 bytes) -> 'unknown'\n{\n  const path = writeTempFile(\"empty.bin\", new Uint8Array(0));\n  tempFiles.push(path);\n\n  const result = detectFileType(path);\n  assertEqual(result, \"unknown\", \"Empty file should be detected as unknown\");\n}\n\n// 4. File shorter than 8 bytes -> 'unknown'\n{\n  const data = new Uint8Array([0x47, 0x54, 0x4b]); // 3 bytes \u2014 partial magic\n  const path = writeTempFile(\"short.bin\", data);\n  tempFiles.push(path);\n\n  const result = detectFileType(path);\n  assertEqual(result, \"unknown\", \"File shorter than 8 bytes should be detected as unknown\");\n}\n\n// 5. Nonexistent path -> 'unknown'\n{\n  const fakePath = GLib.build_filenamev([tmpDir, \"does-not-exist.gtkrypt\"]);\n  const result = detectFileType(fakePath);\n  assertEqual(result, \"unknown\", \"Nonexistent file should be detected as unknown\");\n}\n\n// ---------------------------------------------------------------------------\n// Cleanup\n// ---------------------------------------------------------------------------\n\nfor (const path of tempFiles) {\n  removeTempFile(path);\n}\nremoveTempDir();\n\n// ---------------------------------------------------------------------------\n// Report\n// ---------------------------------------------------------------------------\n\nreport(\"detect\");\n"],
  "mappings": "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",
  "names": ["GLib", "Gio"]
}
